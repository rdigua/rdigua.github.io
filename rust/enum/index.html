<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.59.0-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title> &middot; Jay Blog</title>

  
  <link type="text/css" rel="stylesheet" href="http://blog.jaytogo.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://blog.jaytogo.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jaytogo.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jaytogo.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.jaytogo.com/"><h1>Jay Blog</h1></a>
      <p class="lead">
       learning rust, reviwe c, erp, javascript, blog, python 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://blog.jaytogo.com/">Home</a> </li>
        <li><a href="/rust/"> rust </a></li>
      </ul>
    </nav>

    <p>&copy; 2019. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1></h1>
  <time datetime=0001-01-01T00:00:00Z class="post-date">Mon, Jan 1, 0001</time>
  

<h1 id="virtual-structs-part-1-where-rust-s-enum-shines-http-smallcultfollowing-com-babysteps-blog-2015-05-05-where-rusts-enum-shines-virtual-structs-part-1-where-rusts-enum-shines">Virtual Structs Part 1: Where Rust&rsquo;s enum shines[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#virtual-structs-part-1-where-rusts-enum-shines">http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#virtual-structs-part-1-where-rusts-enum-shines</a>)</h1>

<p>May 5, 2015</p>

<p>One priority for Rust after 1.0 is going to be incorporating some kind of support for  <a href="https://github.com/rust-lang/rfcs/issues/349">“efficient inheritance” or “virtual structs”</a>. In order to motivate and explain this design, I am writing a series of blog posts examining how Rust’s current abstractions compare with those found in other languages.</p>

<p>The way I see it, the topic of “virtual structs” has always had two somewhat orthogonal components to it. The first component is a question of how we can generalize and extend Rust enums to cover more scenarios. The second component is integrating virtual dispatch into this picture.</p>

<p>I am going to start the series by focusing on the question of extending enums. This first post will cover some of the strengths of the current Rust  <code>enum</code>  design; the next post, which I’ll publish later this week, will describe some of the advantages of a more “class-based” approach. Then I’ll discuss how we can bring those two worlds together. After that, I will turn to virtual dispatch, impls, and matching, and show how they interact.</p>

<h3 id="the-rust-enum-http-smallcultfollowing-com-babysteps-blog-2015-05-05-where-rusts-enum-shines-the-rust-enum">The Rust enum[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#the-rust-enum">http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#the-rust-enum</a>)</h3>

<p>I don’t know about you, but when I work with C++, I find that the first thing that I miss is the Rust  <code>enum</code>. Usually what happens is that I start out with some innocent-looking C++ enum, like  <code>ErrorCode</code>:</p>

<pre><code>enum ErrorCode {
    FileNotFound,
    UnexpectedChar
};

ErrorCode parse_file(String file_name);

</code></pre>

<p>As I evolve the code, I find that, in some error cases, I want to return some additional information. For example, when I return  <code>UnexpectedChar</code>, maybe I want to indicate what character I saw, and what characters I expected. Because this data isn’t the same for all errors, now I’m kind of stuck. I can make a struct, but it has these extra fields that are only sometimes relevant, which is awkward:</p>

<pre><code>struct Error {
    ErrorCode code;
    
    // only relevant if UnexpectedChar:
    Vector&lt;char&gt; expected; // possible expected characters
    char found;
};

</code></pre>

<p>This solution is annoying since I have to come up with values for all these fields, even when they’re not relevant. In this case, for example, I have to create an empty vector and so forth. And of course I have to make sure not to read those fields without checking what kind of error I have first. And it’s wasteful of memory to boot. (I could use a  <code>union</code>, but that is kind of a mess of its own.) All in all, not very good.</p>

<p>One more structured solution is to go to a full-blown class hierarchy:</p>

<pre><code>enum ErrorCode {
    FileNotFound,
    UnexpectedChar
};

class Error {
  public:
    Error(ErrorCode ec) : errorCode(ec) { }
    const ErrorCode errorCode;
};

class FileNotFoundError : public Error {    
  public:
    FileNotFound() : Error(FileNotFound);
};

class UnexpectedChar : public ErrorCode {
  public:
    UnexpectedChar(char expected, char found)
      : Error(UnexpectedChar),
        expected(expected),
        found(found)
    { }
    
    const char expected;
    const char found;
};

</code></pre>

<p>In many ways, this is pretty nice, but there is a problem (besides the verbosity, I mean). I can’t just pass around  <code>Error</code>  instances by value, because the size of the  <code>Error</code>  will vary depending on what kind of error it is. So I need dynamic allocation. So I can change my  <code>parse_file</code>  routine to something like:</p>

<pre><code>unique_ptr&lt;Error&gt; parse_file(...);

</code></pre>

<p>Of course, now I’ve wound up with a lot more code, and mandatory memory allocation, for something that doesn’t really seem all that complicated.</p>

<h3 id="rust-to-the-rescue-http-smallcultfollowing-com-babysteps-blog-2015-05-05-where-rusts-enum-shines-rust-to-the-rescue">Rust to the rescue[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#rust-to-the-rescue">http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#rust-to-the-rescue</a>)</h3>

<p>Of course, Rust enums make this sort of thing easy. I can start out with a simple enum as before:</p>

<pre><code>enum ErrorCode {
    FileNotFound,
    UnexpectedChar
}

fn parse_file(file_name: String) -&gt; ErrorCode;

</code></pre>

<p>Then I can simply modify it so that the variants carry data:</p>

<pre><code>enum ErrorCode {
    FileNotFound,
    UnexpectedChar { expected: Vec&lt;String&gt;, found: char }
}

fn parse_file(file_name: String) -&gt; ErrorCode;

</code></pre>

<p>And nothing really has to change. I only have to supply values for those fields when I construct an instance of  <code>UnexpectedChar</code>, and I only read the values when I match a given error. But most importantly, I don’t have to do dummy allocations: the size of  <code>ErrorCode</code>  is automatically the size of the largest variant, so I get the benefits of the a  <code>union</code>  in C but without the mess and risk.</p>

<h3 id="what-makes-rust-and-c-behave-differently-http-smallcultfollowing-com-babysteps-blog-2015-05-05-where-rusts-enum-shines-what-makes-rust-and-c-behave-differently">What makes Rust and C++ behave differently?[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#what-makes-rust-and-c-behave-differently">http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#what-makes-rust-and-c-behave-differently</a>)</h3>

<p>So why does this example work so much more smoothly with a Rust enum than a C++ class hierarchy? The most obvious difference is that Rust’s enum syntax allows us to compactly declare all the variants in one place, and of course we enjoy the benefits of match syntax. Such “creature comforts” are very nice, but that is not what I’m really talking about in this post. (For example, Scala is an example of a language that offers  <a href="http://docs.scala-lang.org/tutorials/tour/case-classes.html">great syntactic support</a>  for using “classes as variants”; but that doesn’t change the fundamental tradeoffs involved.)</p>

<p>To me, the key difference between Rust and C++ is the size of the  <code>ErrorCode</code>  types. In Rust, the size of an  <code>ErrorCode</code>  instance is equal to  <strong>the maximum of its variants</strong>, which means that we can pass errors around by value and know that we have enough space to store any kind of error. In contrast, when using classes in C++, the size of an  <code>ErrorCode</code>  instance will vary,  <strong>depending on what specific variance it is</strong>. This is why I must pass around errors using a pointer, since I don’t know how much space I need up front. (Well, actually, C++ doesn’t  <em>require</em>  you to pass around values by pointer: but if you don’t, you wind up with  <a href="http://stackoverflow.com/questions/274626/what-is-object-slicing">object slicing</a>, which can be a particularly surprising sort of error. In Rust, we have the notion of  <a href="http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/">DST</a>  to address this problem.)</p>

<p><strong>Rust really relies deeply on the flat, uniform layout for enums</strong>. For example, every time you make a nullable pointer like  <code>Option&lt;&amp;T&gt;</code>, you are taking advantage of the fact that options are laid out flat in memory, whether they are  <code>None</code>  or  <code>Some</code>. (In Scala, for example, creating a  <code>Some</code>  variant requires allocating an object.)</p>

<h3 id="preview-of-the-next-few-posts-http-smallcultfollowing-com-babysteps-blog-2015-05-05-where-rusts-enum-shines-preview-of-the-next-few-posts">Preview of the next few posts[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#preview-of-the-next-few-posts">http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#preview-of-the-next-few-posts</a>)</h3>

<p>OK, now that I spent a lot of time telling you why enums are great and subclassing is terrible, my next post is going to tell you why I think suclassing is sometimes fantastic and enums kind of annoying.</p>

<h3 id="caveat-http-smallcultfollowing-com-babysteps-blog-2015-05-05-where-rusts-enum-shines-caveat">Caveat[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#caveat">http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/#caveat</a>)</h3>

<p>I’m well aware I’m picking on C++ a bit unfairly. For example, perhaps instead of writing up my own little class hierarchy, I should be using  <code>boost::any</code>  or something like that. Because C++ is such an extensible language, you can definitely construct a class hierarchy that gives you similar advantages to what Rust enums offer. Heck, you could just write a carefully constructed wrapper around a C  <code>union</code>  to get what you want. But I’m really focused here on contrasting the kind of “core abstractions” that the language offers for handling variants with data, which in Rust’s case is (currently) enums, and in C++’s case is subtyping and classes.</p>

<hr />

<h1 id="virtual-structs-part-2-classes-strike-back-http-smallcultfollowing-com-babysteps-blog-2015-05-29-classes-strike-back-virtual-structs-part-2-classes-strike-back">Virtual Structs Part 2: Classes strike back[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#virtual-structs-part-2-classes-strike-back">http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#virtual-structs-part-2-classes-strike-back</a>)</h1>

<p>May 29, 2015</p>

<p>This is the second post summarizing my current thoughts about ideas related to “virtual structs”. In the  <a href="http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/">last post</a>, I described how, when coding C++, I find myself missing Rust’s enum type. In this post, I want to turn it around. I’m going to describe why the class model can be great, and something that’s actually kind of missing from Rust. In the next post, I’ll talk about how I think we can get the best of both worlds for Rust. As in the first post, I’m focusing here primarily on the data layout side of the equation; I’ll discuss virtual dispatch afterwards.</p>

<h3 id="very-brief-recap-http-smallcultfollowing-com-babysteps-blog-2015-05-29-classes-strike-back-very-brief-recap">(Very) brief recap[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#very-brief-recap">http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#very-brief-recap</a>)</h3>

<p>In the previous post, I described how one can setup a class hierarchy in C++ (or Java, Scala, etc) with a base class and one subclass for every variant:</p>

<pre><code>class Error { ... };
class FileNotFound : public Error { ... };
class UnexpectedChar : public Error { ... };

</code></pre>

<p>This winds up being very similar to a Rust enum:</p>

<pre><code>enum ErrorCode {
    FileNotFound,
    UnexpectedChar
}

</code></pre>

<p>However, there are are some important differences. Chief among them is that the Rust enum has a size equal to the size of its largest variant, which means that Rust enums can be passed “by value” rather than using a box. This winds up being absolutely crucial to Rust: it’s what allows us to use  <code>Option&lt;&amp;T&gt;</code>, for example, as a zero-cost nullable pointer. It’s what allows us to make arrays of enums (rather than arrays of boxed enums). It’s what allows us to overwrite one enum value with another, e.g. to change from  <code>None</code>  to  <code>Some(_)</code>. And so forth.</p>

<h3 id="problem-1-memory-bloat-http-smallcultfollowing-com-babysteps-blog-2015-05-29-classes-strike-back-problem-1-memory-bloat">Problem #1: Memory bloat[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#problem-1-memory-bloat">http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#problem-1-memory-bloat</a>)</h3>

<p>There are a lot of use cases, however, where having a size equal to the largest variant is actually a handicap. Consider, for example, the way the rustc compiler represents Rust types (this is actually a cleaned up and simplified version of the  <a href="https://github.com/rust-lang/rust/blob/9854143cba679834bc4ef932858cd5303f015a0e/src/librustc/middle/ty.rs#L1359-L1397">real thing</a>).</p>

<p>The type  <code>Ty</code>  represents a rust type:</p>

<pre><code>// 'tcx is the lifetime of the arena in which we allocate type information
type Ty&lt;'tcx&gt; = &amp;'tcx TypeStructure&lt;'tcx&gt;;

</code></pre>

<p>As you can see, it is in fact a reference to a  <code>TypeStructure</code>  (this is called  <code>sty</code>  in the Rust compiler, which isn’t completely up to date with modern Rust conventions). The lifetime  <code>'tcx</code>  here represents the lifetime of the arena in which we allocate all of our type information. So when you see a type like  <code>&amp;'tcx</code>, it represents interned information allocated in an arena. (As an aside, we  <a href="https://github.com/rust-lang/rust/pull/1759">added the arena</a>  back before we even had lifetimes at all, and used to use unsafe pointers here. The fact that we use proper lifetimes here is thanks to the awesome  <a href="https://github.com/eddyb/">eddyb</a>  and his super duper  <a href="https://github.com/rust-lang/rust/pull/18483">safe-ty</a>  branch. What a guy.)</p>

<p>So, here is the first observation: in practice, we are already boxing all the instances of  <code>TypeStructure</code>(you may recall that the fact that classes forced us to box was a downside before). We have to, because types are recursively structured. In this case, the ‘box’ is an arena allocation, but still the point remains that we always pass types by reference. And, moreover, once we create a  <code>Ty</code>, it is immutable – we never switch a type from one variant to another.</p>

<p>The actual  <code>TypeStructure</code>  enum is defined something like this:</p>

<pre><code>enum TypeStructure&lt;'tcx&gt; {
    Bool,                                      // bool
    Reference(Region, Mutability, Type&lt;'tcx&gt;), // &amp;'x T, &amp;'x mut T
    Struct(DefId, &amp;'tcx Substs&lt;'tcx&gt;),         // Foo&lt;..&gt;
    Enum(DefId, &amp;'tcx Substs&lt;'tcx&gt;),           // Foo&lt;..&gt;
    BareFn(&amp;'tcx BareFnData&lt;'tcx&gt;),            // fn(..)
    ...
}

</code></pre>

<p>You can see that, in addition to the types themselves, we also intern a lot of the data in the variants themselves. For example, the  <code>BareFn</code>  variant takes a  <code>&amp;'tcx BareFnData&lt;'tcx&gt;</code>. The reason we do this is because otherwise the size of the  <code>TypeStructure</code>  type balloons very quickly. This is because some variants, like  <code>BareFn</code>, have a lot of associated data (e.g., the ABI, the types of all the arguments, etc). In contrast, types like structs or references have relatively little associated data. Nonetheless, the size of the  <code>TypeStructure</code>  type is determined by the largest variant, so it doesn’t matter if all the variants are small but one: the enum is still large. To fix this,  <a href="https://github.com/huonw">Huon</a>  <a href="https://github.com/rust-lang/rust/pull/19549">spent quite a bit of time</a>  analyzing the size of each variant and introducing indirection and interning to bring it down.</p>

<p>Consider what would have happened if we had used classes instead. In that case, the type structure might look like:</p>

<pre><code>typedef TypeStructure *Ty;
class TypeStructure { .. };
class Bool : public TypeStructure { .. };
class Reference : public TypeStructure { .. };
class Struct : public TypeStructure { .. };
class Enum : public TypeStructure { .. };
class BareFn : public TypeStructure { .. };

</code></pre>

<p>In this case, whenever we allocated a  <code>Reference</code>  from the arena, we would allocate precisely the amount of memory that a  <code>Reference</code>  needs. Similarly, if we allocated a  <code>BareFn</code>  type, we’d use more memory for that particular instance, but it wouldn’t affect the other kinds of types. Nice.</p>

<h3 id="problem-2-common-fields-http-smallcultfollowing-com-babysteps-blog-2015-05-29-classes-strike-back-problem-2-common-fields">Problem #2: Common fields[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#problem-2-common-fields">http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#problem-2-common-fields</a>)</h3>

<p>The definition for  <code>Ty</code>  that I gave in the previous section was actually somewhat simplified compared to what we really do in rustc. The actual definition looks more like:</p>

<pre><code>// 'tcx is the lifetime of the arena in which we allocate type information
type Ty&lt;'tcx&gt; = &amp;'tcx TypeData&lt;'tcx&gt;;

struct TypeData&lt;'tcx&gt; {
    id: u32,
    flags: u32,
    ...,
    structure: TypeStructure&lt;'tcx&gt;,
}

</code></pre>

<p>As you can see,  <code>Ty</code>  is in fact a reference not to a  <code>TypeStructure</code>  directly but to a struct wrapper,  <code>TypeData</code>. This wrapper defines a few fields that are common to all types, such as a unique integer id and a set of flags. We could put those fields into the variants of  <code>TypeStructure</code>, but it’d be repetitive, annoying, and inefficient.</p>

<p>Nonetheless, introducing this wrapper struct feels a bit indirect. If we are using classes, it would be natural for these fields to live on the base class:</p>

<pre><code>typedef TypeStructure *Ty;
class TypeStructure {
    unsigned id;
    unsigned flags;
    ...
};
class Bool : public TypeStructure { .. };
class Reference : public TypeStructure { .. };
class Struct : public TypeStructure { .. };
class Enum : public TypeStructure { .. };
class BareFn : public TypeStructure { .. };

</code></pre>

<p>In fact, we could go further. There are many variants that share common bits of data. For example, structs and enums are both just a kind of nominal type (“named” type). Almost always, in fact, we wish to treat them the same. So we could refine the hierarchy a bit to reflect this:</p>

<pre><code>class Nominal : public TypeStructure {
    DefId def_id;
    Substs substs;
};
class Struct : public Nominal {
};
class Enum : public Nominal {
};

</code></pre>

<p>Now code that wants to work uniformly on either a struct or enum could just take a  <code>Nominal*</code>.</p>

<p>Note that while it’s relatively easy in Rust to handle the case where  <em>all</em>  variants have common fields, it’s a lot more awkward to handle a case like  <code>Struct</code>  or  <code>Enum</code>, where only  <em>some</em>  of the variants have common fields.</p>

<h3 id="problem-3-initialization-of-common-fields-http-smallcultfollowing-com-babysteps-blog-2015-05-29-classes-strike-back-problem-3-initialization-of-common-fields">Problem #3: Initialization of common fields[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#problem-3-initialization-of-common-fields">http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#problem-3-initialization-of-common-fields</a>)</h3>

<p>Rust differs from purely OO languages in that it does not have special constructors. An instance of a struct in Rust is constructed by supplying values for all of its fields. One great thing about this approach is that “partially initialized” struct instances are never exposed. However, the Rust approach has a downside, particularly when we consider code where you have lots of variants with common fields: there is no way to write a fn that initializes  <em>only</em>  the common fields.</p>

<p>C++ and Java take a different approach to initialization based on  <em>constructors</em>. The idea of a constructor is that you first allocate the complete structure you are going to create, and then execute a routine which fills in the fields. This approach to constructos has a lot of problems – some of which I’ll detail below – and I would not advocate for adding it to Rust. However, it does make it convenient to separately abstract over the initialization of base class fields from subclass fields:</p>

<pre><code>typedef TypeStructure *Ty;
class TypeStructure {
    unsigned id;
    unsigned flags;
    
    TypeStructure(unsigned id, unsigned flags)
      : id(id), flags(flags)
    { }
};

class Bool : public TypeStructure {
    Bool(unsigned id)
      : TypeStructure(id, 0) // bools have no flags
    { }
};

</code></pre>

<p>Here, the constructor for  <code>TypeStructure</code>  initializes the  <code>TypeStructure</code>  fields, and the  <code>Bool</code>  constructor initializes the  <code>Bool</code>  fields. Imagine we were to add a field to  <code>TypeStructure</code>  that is always 0, such as some sort of counter. We could do this without changing any of the subclasses:</p>

<pre><code>class TypeStructure {
    unsigned id;
    unsigned flags;
    unsigned counter; // new
    
    TypeStructure(unsigned id, unsigned flags)
      : id(id), flags(flags), counter(0)
    { }
};

</code></pre>

<p>If you have a lot of variants, being able to extract the common initialization code into a function of some kind is pretty important.</p>

<p>Now, I promised a critique of constructors, so here we go. The biggest reason we do not have them in Rust is that constructors rely on exposing a partially initialized  <code>this</code>  pointer. This raises the question of what value the fields of that  <code>this</code>  pointer have before the constructor finishes: in C++, the answer is just undefined behavior. Java at least guarantees that everything is zeroed. But since Rust lacks the idea of a “universal null” – which is an important safety guarantee! – we don’t have such a convenient option. And there are other weird things to consider: what happens if you call a virtual function during the base type constructor, for example? (The answer here again varies by language.)</p>

<p>So, I don’t want to add OO-style constructors to Rust, but I do want some way to pull out the initialization code for common fields into a subroutine that can be shared and reused. This is tricky.</p>

<h3 id="problem-4-refinement-types-http-smallcultfollowing-com-babysteps-blog-2015-05-29-classes-strike-back-problem-4-refinement-types">Problem #4: Refinement types[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#problem-4-refinement-types">http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#problem-4-refinement-types</a>)</h3>

<p>Related to the last point, Rust currently lacks a way to “refine” the type of an enum to indicate the set of variants that it might be. It would be great to be able to say not just “this is a  <code>TypeStructure</code>”, but also things like “this is a  <code>TypeStructure</code>  that corresponds to some nominal type (i.e., a struct or an enum), though I don’t know precisely which kind”. As you’ve probably surmised, making each variant its own type – as you would in the classes approach – gives you a simple form of refinement types for free.</p>

<p>To see what I mean, consider the class hierarchy we built for  <code>TypeStructure</code>:</p>

<pre><code>typedef TypeStructure *Ty;
class TypeStructure { .. };
class Bool : public TypeStructure { .. };
class Reference : public TypeStructure { .. };
class Nominal : public TypeStructure { .. }
class Struct : public Nominal { .. };
class Enum : public Nominal { .. };
class BareFn : public TypeStructure { .. };

</code></pre>

<p>Now, I can pass around a  <code>TypeStructure*</code>  to indicate “any sort of type”, or a  <code>Nominal*</code>  to indicate “a struct or an enum”, or a  <code>BareFn*</code>  to mean “a bare fn type”, and so forth.</p>

<p>If we limit ourselves to single inheritance, that means one can construct an arbitrary tree of refinements. Certainly one can imagine wanting arbitrary refinements, though in my own investigations I have always found a tree to be sufficient. In C++ and Scala, of course, one can use multiple inheritance to create arbitrary refinements, and I think one can imagine doing something similar in Rust with traits.</p>

<p>As an aside, the right way to handle ‘datasort refinements’ has been a topic of discussion in Rust for some time; I’ve posted a  <a href="http://smallcultfollowing.com/babysteps/blog/2012/08/24/datasort-refinements/">different proposal</a>  in the past, and, somewhat amusingly, my  <a href="http://smallcultfollowing.com/babysteps/blog/2011/12/02/why-case-classes-are-better-than-variant-types/">very first post</a>  on this blog was on this topic as well. I personally find that building on a variant hierarchy, as above, is a very appealing solution to this problem, because it avoids introducing a “new concept” for refinements: it just leverages the same structure that is giving you common fields and letting you control layout.</p>

<h3 id="conclusion-http-smallcultfollowing-com-babysteps-blog-2015-05-29-classes-strike-back-conclusion">Conclusion[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#conclusion">http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#conclusion</a>)</h3>

<p>So we’ve seen that there also advantages to the approach of using subclasses to model variants. I showed this using the  <code>TypeStructure</code>  example, but there are lots of cases where this arises. In the compiler alone, I would say that the abstract syntax tree, the borrow checker’s  <code>LoanPath</code>, the memory categorization  <code>cmt</code>  types, and probably a bunch of other cases would benefit from a more class-like approach. Servo developers have long been requesting something more class-like for use in the DOM. I feel quite confident that there are many other crates at large that could similarly benefit.</p>

<p>Interestingly, Rust can gain a lot of the benefits of the subclass approach—namely, common fields and refinement types—just by making enum variants into types. There have  <a href="https://github.com/rust-lang/rfcs/issues/349">been proposals</a>  along these lines before, and I think that’s an important ingredient for the final plan.</p>

<p>Perhaps the biggest difference between the two approaches is the size of the “base type”. That is, in Rust’s current enum model, the base type (<code>TypeStructure</code>) is the size of the maximal variant. In the subclass model, the base class has an indeterminate size, and so must be referenced by pointer. Neither of these are an “expressiveness” distinction—we’ve seen that you can model anything in either approach. But it has a big effect on how easy it is to write code.</p>

<p>One interesting question is whether we can concisely state conditions in which one would prefer to have “precise variant sizes” (class-like) vs “largest variant” (enum). I think the “precise sizes” approach is better when the following apply:</p>

<ol>
<li>A recursive type (like a tree), which tends to force boxing anyhow. Examples: the AST or types in the compiler, DOM in servo, a GUI.</li>
<li>Instances never change what variant they are.</li>
<li>Potentially wide variance in the sizes of the variants.</li>
</ol>

<p>The fact that this is really a kind of efficiency tuning is an important insight. Hopefully our final design can make it relatively easy to change between the ‘maximal size’ and the ‘unknown size’ variants, since it may not be obvious from the get go which is better.</p>

<h3 id="preview-of-the-next-post-http-smallcultfollowing-com-babysteps-blog-2015-05-29-classes-strike-back-preview-of-the-next-post">Preview of the next post[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#preview-of-the-next-post">http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/#preview-of-the-next-post</a>)</h3>

<p>The next post will describe a scheme in which we could wed together enums and structs, gaining the advantages of both. I don’t plan to touch virtual dispatch yet, but intead just keep focusing on concrete types.</p>

<hr />

<h1 id="virtual-structs-part-3-bringing-enums-and-structs-together-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-virtual-structs-part-3-bringing-enums-and-structs-together">Virtual Structs Part 3: Bringing Enums and Structs Together[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#virtual-structs-part-3-bringing-enums-and-structs-together">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#virtual-structs-part-3-bringing-enums-and-structs-together</a>)</h1>

<p>Aug 20, 2015</p>

<p>So, in  <a href="http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/">previous</a>  <a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/">posts</a>, I discussed the pros and cons of two different approaches to modeling variants: Rust-style enums and C++-style classes. In those posts, I explained why I see Rust enums and OO-style class hierarchies as more alike than different (I personally credit Scala for opening my eyes to this, though I’m sure it’s been understood by others for much longer). The key points were as follows:</p>

<ul>
<li>Both Rust-style enums and C++-style classes can be used to model the idea of a value that be one of many variants, but there are differences in how they work at runtime. These differences mean that Rust-style enums are more convenient for some tasks, and C++-style classes for others. In particular:

<ul>
<li>A Rust-style enum is sized as large as the largest variant. This is great because you can lay them out flat in another data structure without requiring any allocation. You can also easily change from one variant to another. One downside of Rust enums is that you cannot “refine” them to narrow the set of variants that a particular value can have.</li>
<li>A C++-style class is sized to be exactly as big as one variant. This is great because it can be much more memory efficient. However, if you don’t know what variant you have, you must manipulate the value by pointer, so it tends to require more allocation. It is also impossible to change from one variant to another. Class hierarchies also give you a simple, easily understood kind of refinement, and the ability to have common fields that are shared between variants.</li>
</ul></li>
<li>C++-style classes offer constructors, which allows for more abstraction and code reuse when initially creating an instance, but raise thorny questions about the type of a value under construction; Rust structs and enums are always built in a single-shot today, which is simpler and safer but doesn’t compose as well.</li>
</ul>

<p>What I want to talk about in this post is a proposal (or proto-proposal) for bridging those two worlds in Rust. I’m going to focus on data layout in this post. I’ll defer virtual methods for another post (or perhaps an RFC).  <em>Spoiler alert:</em>  they can be viewed as a special case of  <a href="https://github.com/rust-lang/rfcs/pull/1210">specialization</a>.</p>

<p>I had originally intended to publish this post a few days after the others. Obviously, I got delayed. Sorry about that! Things have been very busy! In any case, better late than never, as some-great-relative-or-other always (no doubt) said. Truth is, I really miss blogging regularly, so I’m going to make an effort to write up more “in progress” and half-baked ideas (yeah yeah, promises to blog more are a dime a dozen, I know).</p>

<p><em>Note:</em>  I want to be clear that the designs in this blog post are not “my” work per se. Some of the ideas originated with me, but others have arisen in the course of conversations with others, as well as earlier proposals from nrc, which in turn were heavily based on community feedback. And of course it’s not like we Rust folk invented OO or algebraic data types or anything in the first place. :)</p>

<h3 id="unifying-structs-and-enums-into-type-hierarchies-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-unifying-structs-and-enums-into-type-hierarchies">Unifying structs and enums into type hierarchies[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#unifying-structs-and-enums-into-type-hierarchies">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#unifying-structs-and-enums-into-type-hierarchies</a>)</h3>

<p>The key idea is to generalize enums and structs into a single concept. This is often called an  <em>algebraic data type</em>, but “algebra” brings back memories of balancing equations in middle school (not altogether unpleasant ones, admittedly), so I’m going to use the term  <em>type hierarchy</em>  instead. Anyway, to see what I mean, let’s look at my favorite enum ever,  <code>Option</code>:</p>

<pre><code>enum Option&lt;T&gt; {
    Some(T), None
}

</code></pre>

<p>The idea is to reinterpret this enum as three types arranged into a tree or hierarchy. An important point is that every node in the tree is now a type: so there is a type representing the  <code>Some</code>  variant, and a type representing the  <code>None</code>  variant:</p>

<pre><code>enum Option&lt;T&gt;
|
+- struct None&lt;T&gt;
+- struct Some&lt;T&gt;

</code></pre>

<p>As you can see, the leaves of the tree are called structs. They represent a particular variant. The inner nodes are called enums, and they represent a set of variants. Every existing  <code>struct</code>  definition can also be reinterpreted as a hierarchy, but just a hierarchy of size 1.</p>

<p>These generalized type hierarchies can be any depth. This means you can do nested enums, like:</p>

<pre><code>enum Mode {
    enum ByRef {
        Mutable,
        Immutable
    }
    ByValue
}

</code></pre>

<p>This creates a nested hierarchy:</p>

<pre><code>enum Mode
|
+- enum ByRef
|  |
|  +- struct Mutable
|  +- struct Immutable
+- ByValue

</code></pre>

<p>Since all the nodes in a hiearchy are types, we get refinement types for free. This means that I can use  <code>Mode</code>  as a type to mean “any mod at all”, or  <code>Mode::ByRef</code>  for the times when I know something is one of the  <code>ByRef</code>  modes, or even  <code>Mode::ByRef::Mutable</code>  (which is a singleton struct).</p>

<p>As part of this change, it should be possible to declare the variants out of line. For example, we could change enum to look as follows:</p>

<pre><code>enum Option&lt;T&gt; {
}
struct Some&lt;T&gt;: Option&lt;T&gt; {
    value: T
}
struct None&lt;T&gt;: Option&lt;T&gt; {
}

</code></pre>

<p>This definitely is not exactly equivalent to the older one, of course. The names  <code>Some</code>  and  <code>None</code>  live alongside  <code>Option</code>, rather than within it, and I’ve used a field (<code>value</code>) rather than a tuple struct.</p>

<h3 id="common-fields-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-common-fields">Common fields[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#common-fields">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#common-fields</a>)</h3>

<p>Enum declarations are extended with the ability to have fields as well as variants. These fields are inherited by all variants of that enum. In the syntax, fields must appear before the variants, and it is also not possible to combine “tuple-like” structs with inherited fields.</p>

<p>Let’s revisit an example from  <a href="http://smallcultfollowing.com/babysteps/blog/2015/05/29/classes-strike-back/">the previous post</a>. In the compiler, we currently represent types with an enum. However, there are certain fields that every type carries. These are handled via a separate struct, so that we wind up with something like this:</p>

<pre><code>type Ty&lt;'tcx&gt; = &amp;'tcx TypeData&lt;'tcx&gt;;

struct TypeData&lt;'tcx&gt; {
    id: u32,
    flags: u32,
    ...,
    structure: TypeStructure&lt;'tcx&gt;,
}

enum TypeStructure&lt;'tcx&gt; {
    Int,
    Uint,
    Ref(Ty&lt;'tcx&gt;),
    ...
}

</code></pre>

<p>Under this newer design, we could simply include the common fields in the enum definition:</p>

<pre><code>type Ty&lt;'tcx&gt; = &amp;'tcx TypeData&lt;'tcx&gt;;

enum TypeData&lt;'tcx&gt; {
    // Common fields:
    id: u32,
    flags: u32,
    ...,

    // Variants:
    Int { },
    Uint { },
    Ref { referent_ty: Ty&lt;'tcx&gt; },
    ...
}

</code></pre>

<p>Naturally, when I create a  <code>TypeData</code>  I should supply all the fields, including the inherited ones (though in a later section I’ll present ways to extract the initialization of common fields into a reusable fn):</p>

<pre><code>let ref =
    TypeData::Ref {
        id: id,
        flags: flags,
        referent_ty: some_ty
    };

</code></pre>

<p>And, of course, given a reference  <code>&amp;TypeData&lt;'tcx&gt;</code>, we can access these common fields:</p>

<pre><code>fn print_id&lt;'tcx&gt;(t: &amp;TypeData&lt;'tcx&gt;) {
    println!(&quot;The id of `{:?}` is `{:?}`&quot;, t, t.id);
}

</code></pre>

<p>Convenient!</p>

<h3 id="unsized-enums-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-unsized-enums">Unsized enums[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#unsized-enums">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#unsized-enums</a>)</h3>

<p>As today, the size of an enum type, by default, is equal to the largest of its variants. However, as I’ve outlined in the last two posts, it is often useful to have each value be sized to a particular variant. In the previous posts I identified some criteria for when this is the case:</p>

<p><em>One interesting question is whether we can concisely state conditions in which one would prefer to have “precise variant sizes” (class-like) vs “largest variant” (enum). I think the “precise sizes” approach is better when the following apply:</em></p>

<ul>
<li><em>A recursive type (like a tree), which tends to force boxing anyhow. Examples: the AST or types in the compiler, DOM in servo, a GUI.</em></li>
<li><em>Instances never change what variant they are.</em></li>
<li><em>Potentially wide variance in the sizes of the variants.</em></li>
</ul>

<p>Therefore, it is possible to declare the root enum in a type hierarchy as either sized (the default) or  <em>unsized</em>; this choice is inherited by all enums in the hierarchy. If the hierarchy is declared as unsized, it means that  <strong>each struct type will be sized just as big as it needs to be</strong>. This means in turn that the  <strong>enum types in the hierarchy are unsized types</strong>, since the space required will vary depending on what variant an instance happens to be at runtime.</p>

<p>To continue with our example of types in rustc, we currently go through some contortions so as to introduce indirection for uncommon cases, which keeps the size of the enum under control:</p>

<pre><code>type Ty&lt;'tcx&gt; = &amp;'tcx TypeData&lt;'tcx&gt;;

enum TypeData&lt;'tcx&gt; {
    ...,

    // The data for a fn type is stored in a different struct
    // which is cached in a special arena. This is helpful
    // because (a) the size of this variant is only a single word
    // and (b) if we have a type that we know is a fn pointer,
    // we can pass the `BareFnTy` struct around instead of the
    // `TypeData`.
    FnPointer { data: &amp;'tcx FnPointerData&lt;'tcx&gt; },
}

struct FnPointerData&lt;'tcx&gt; {
    unsafety: Unsafety,
    abi: Abi,
    signature: Signature,
}

</code></pre>

<p>As discussed in a comment in the code, the current scheme also serves as a poor man’s refinement type: if at some point in the code we know we have a fn pointer, we can write a function that takes a<code>FnPointerData</code>  argument to express that:</p>

<pre><code>fn process_ty&lt;'tcx&gt;(ty: Ty&lt;'tcx&gt;) {
    match ty {
        &amp;TypeData::FnPointer { data, .. } =&gt; {
            process_fn_ty(ty, data)
        }
        ...
    }
}

// This function expects that `ty` is a fn pointer type. The `FnPointerData`
// contains the fn pointer information for `ty`.
fn process_fn_ty&lt;'tcx&gt;(ty: Ty&lt;'tcx&gt;, data: &amp;FnPointerData&lt;'tcx&gt;) {
}

</code></pre>

<p>This pattern works OK in practice, but it is not perfect. For one thing, it’s tedious to construct, and it’s also a little inefficient. It introduces unnecessary indirection and a second memory arena. Moreover, the refinement type scheme isn’t great, because you often have to pass both the  <code>ty</code>  (for the common fields) and the internal  <code>data</code>.</p>

<p>Using a type hierarchy, we can do much better. We simply remove the  <code>FnPointerData</code>  struct and inline its fields directly into  <code>TypeData</code>:</p>

<pre><code>type Ty&lt;'tcx&gt; = &amp;'tcx TypeData&lt;'tcx&gt;;

unsized enum TypeData&lt;'tcx&gt; {
    ...,

    // No indirection anymore. What's more, the type `FnPointer`
    // serves as a refinement type automatically.
    FnPointer {
        unsafety: Unsafety,
        abi: Abi,
        signature: Signature,
    }
}

</code></pre>

<p>Now we can write functions that process specific categories of types very naturally:</p>

<pre><code>fn process_ty&lt;'tcx&gt;(ty: Ty&lt;'tcx&gt;) {
    match ty {
        fn_ty @ &amp;TypeData::FnPointer { .. } =&gt; {
            process_fn_ty(fn_ty)
        }
        ...
    }
}

// Don't even need a comment: it's obvious that `ty` should be a fn type
// (and enforced by the type system).
fn process_fn_ty&lt;'tcx&gt;(ty: &amp;TypeData::FnPointer&lt;'tcx&gt;) {
}

</code></pre>

<h3 id="matching-as-downcasting-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-matching-as-downcasting">Matching as downcasting[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#matching-as-downcasting">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#matching-as-downcasting</a>)</h3>

<p>As the previous example showed, one can continue to use match to select the variant from an enum (sized or not). Maching also gives us an elegant downcasting mechanism. Instead of writing  <code>(Type) value</code>, as in Java, or  <code>dynamic_cast&lt;Type&gt;(value)</code>, one writes  <code>match value</code>  and handles the resulting cases. Just as with enums today,  <code>if let</code>  can be used if you just want to handle a single case.</p>

<h3 id="crate-locality-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-crate-locality">Crate locality[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#crate-locality">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#crate-locality</a>)</h3>

<p>An important part of the design is that the entire type hierarchy must be declared  <strong>within a single crate</strong>. This is of course trivially true today: all variants of an enums are declared in one item, and structs correspond to singleton hierarchies.</p>

<p>Limiting the hierarchy to a single crate has a lot of advantages. Without it, you simply can’t support today’s “sized” enums, for one thing. It allows us to continue doing exhaustive checks for matches and to generate more efficient code. It is interesting to compare to  <code>dynamic_cast</code>, the C++ equivalent to a match:</p>

<ul>
<li><code>dynamic_cast</code>  is often viewed as a kind of code smell, versus a virtual method. I’m inclined to agree, as  <code>dynamic_cast</code>  only checks for a particular variant, rather than specifying handling for the full range of variants; this makes it fragile in the face of edits to the code. In contrast, the exhaustive nature of a Rust  <code>match</code>  ensures that you handle every case (of course, one must still be judicious in your use of  <code>_</code>  patterns, which, while convenient, can be a refactoring hazard).</li>
<li><code>dynamic_cast</code>  is somewhat inefficient, since it must handle the fully general case of classes that spread across compilation units; in fact, it is very uncommon to have a class hierarchy that is truly extensible – and in such cases, using  <code>dynamic_cast</code>  is particularly hard to justify. This leads to projects like LLVM  <a href="http://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions">reimplementing RTTI (the C++ name for matching) from scratch</a>.</li>
</ul>

<p>Another advantage of confining the hierarchy to a single crate is that it allows us to continue doing variance inference across the entire hierarchy at once. This means that, for example, that in the “out of line” version of  <code>Option</code>  (below) we can infer a variance for the parameter  <code>T</code>  declared on  <code>Option</code>, in the same way we do today (otherwise, the declaration of  <code>enum Option&lt;T&gt;</code>  would require some form of phantom data, and that would be  <em>binding</em>  on the types declared in other crates).</p>

<p>I also find that confining the hierarchy to a single crate helps to clarify the role of type hierarchies versus traits and, in turn, avoid some of the pitfalls so beloved by OO haters. Basically, it means that if you want to define an open-ended extension point, you must use a trait, which also offers the most flexibility; a type hierarchy, like an enum today, can only be used to offer a choice between a fixed number of crate-local types. An analogous situation in Java would be deciding between an abstract base class and an interface; under this design, you would have to use an interface (note that the problem of code reuse can be tackled separately, [via specialization]).</p>

<p><em>Finally,</em>  confining extension to a trait is relevant to the construction of vtables and handling of specialization, but we’ll dive into that another time.</p>

<p>Even though I think that limiting type hierarchies to a single crate is very helpful, it’s worth pointing out that it IS possible to lift this restriction if we so choose. This can’t be done in all cases, though, due to some of the inherent limitations involved.</p>

<h3 id="enum-types-as-bounds-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-enum-types-as-bounds">Enum types as bounds[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#enum-types-as-bounds">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#enum-types-as-bounds</a>)</h3>

<p>In the previous section, I mentioned that enums and traits (both today and in this proposed design) both form a kind of interface. Whereas traits define a list of methods, enums indicate something about the memory layout of the value: for example, they can tell you about a common set of fields (though not the complete set), and they clearly narrow down the universe of types to be just the relevant variants. Therefore, it makes sense to be able to use an enum type as a bound on a type parameter. Let’s dive into an example to see what I mean and why you might want this.</p>

<p>Imagine we’re using a type hiererachy to represent the  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">HTML DOM</a>. It might look something like this (browser people: forgive my radical oversimplification):</p>

<pre><code>unsized enum Node {
  // where this node is positioned after layout
  position: Rectangle,
  ...
}

enum Element: Node {
  ...
}

struct TextElement: Element {
  ...
}

struct ParagraphElement: Element {
  ...
}

...

</code></pre>

<p>Now imagine that I have a helper function that selects nodes based on whether they intersect a particular box on the screen:</p>

<pre><code>fn intersects(box: Rectangle, elements: &amp;[Rc&lt;Node&gt;]) -&gt; Vec&lt;Rc&lt;Node&gt;&gt; {
    let mut result = vec![];
    for element in elements {
        if element.position.intersects(box) {
            result.push(element.clone());
        }
    }
    result
}

</code></pre>

<p>OK, great! But now imagine that I have a slice of text elements (<code>&amp;[Rc&lt;TextElement&gt;]</code>), and I would like to use this function. I will get back a  <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>  – I’ve lost track of the fact that my input contained only text elements.</p>

<p>Using generics and bounds, I can rewrite the function:</p>

<pre><code>fn intersects&lt;T:Node&gt;(box: Rectangle, elements: &amp;[Rc&lt;T&gt;]) -&gt; Vec&lt;Rc&lt;T&gt;&gt; {
    // identical to before
}

</code></pre>

<p>Nothing in the body had to change, only the signature.</p>

<p>Permitting enum types to appear as bounds also means that they can be referenced by traits as supertraits. This allows you to define interfaces that cut across the primary inheritance hierarchy. So, for example, in the DOM both the  <code>HTMLTextAreaElement</code>  and the  <code>HTMLInputElement</code>  can carry a block of text, which implies that they have a certain set of text-related methods and properties in common. And of course they are both elements. This can be modeled using a trait like so:</p>

<pre><code>trait TextAPIs: HTMLElement {
    fn maxLength(&amp;self) -&gt; usize;
    ..
}

</code></pre>

<p>This means that if you have an  <code>&amp;TextApis</code>  object, you can access the fields from  <code>HTMLElement</code>  with no overhead, because they are stored in the same place for both cases. But if you want to access other things, such as  <code>maxLength</code>, that implies virtual dispatch, since the address is dynamically computed and will vary.</p>

<h4 id="enums-vs-traits-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-enums-vs-traits">Enums vs traits[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#enums-vs-traits">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#enums-vs-traits</a>)</h4>

<p>The notion of enums as bounds raises questions about potential overlap in purpose between enums and traits. I would argue that this overlap already exists: both enums and traits today are ways to let you write a single function that operates over values of more than one type. However, in practice, it’s rarely hard to know which one you want to use. This I think is because they come at the problem from two different angles:</p>

<ul>
<li>Traits start with the assumption that you want to work with any type, and let you narrow that. Basically, you get code that is  <em>as general as possible</em>.</li>
<li>In contrast, enums assume you want to work with a fixed set of types. This means you can write code that is  <em>as specific as possible</em>. Enums also work best when the types you are choosing between are related into a kind of family, like “all the different variants of types in the Rust language” or “some and none”.</li>
</ul>

<p>If we extend enums in the way described here, then they will become more capable and convenient, and so you might find that they overlap a bit more with plausible use cases for traits. However, I think that in practice there are still clear guidelines for which to choose when:</p>

<ul>
<li>If you have a fixed set of related types, use an enum. Having an enumerated set of cases is advantageous in a lot of ways: we can generate faster code, you can write matches, etc.</li>
<li>If you want open-ended extension, use a trait (and/or trait object). This will ensure that your code makes as few assumptions as possible, which in turn means that you can handle as many clients as possible.</li>
</ul>

<p>Because enums are tied to a fixed set of cases, they allow us to generate tighter code, particularly when you are not monomorphizing to a particular variant. That is, if you have a value of type  <code>&amp;TypeData</code>, where  <code>TypeData</code>  is the enum we mentioned before, you can access common fields at no overhead, even though we don’t know what variant it is. Moreover, the pointer is thin and thus takes only a single word.</p>

<p>In contrast, if you had made  <code>TypeData</code>  a trait and hence  <code>&amp;TypeData</code>  was a trait object, accessing common fields would require some overhead. (This is true even if we were to add “virtual fields” to traits, as  <a href="https://github.com/rust-lang/rfcs/pull/250">eddyb and kimundi proposed in RFC #250</a>.) Also, because traits are “added on” to other values, your pointer would be a fat pointer, and hence take two words.</p>

<p>(As an aside, I still like the idea of adding virtual fields to traits. The idea is that these fields could be “remapped” in an implementation to varying offsets. Accessing such a field implies dynamically loading the offset, which is slower than a regular field but faster than a virtual call. If we additionally added the restriction that those fields must access content that is orthogonal from one another, we might be able to make the borrow checker more permissive in the field case as well. But that is kind of an orthogonal extension to what I’m talking about here – and one that fits well with my framing of “traits are for open-ended extension across heterogeneous types, enums are for a single cohesive type hierarchy”.)</p>

<h3 id="associated-structs-constructors-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-associated-structs-constructors">Associated structs (constructors)[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#associated-structs-constructors">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#associated-structs-constructors</a>)</h3>

<p>One of the distinctive features of OO-style classes is that they feature constructors. Constructors allow you to layer initialization code, so that you can build up a function that initializes (say) the fields for  <code>Node</code>, and that function is used as a building block by one that initializes the  <code>Element</code>  fields, and so on down the hierarchy. This is good for code reuse, but constructors have an Achilles heel: while we are initializing the  <code>Node</code>  fields, what value do the  <code>Element</code>  fields have? In C++, the answer is “who knows” – the fields are simply uninitialized, and accessing them is undefined behavior. In Java, they are null. But Rust has no such “convenient” answer. And there is an even weirder question: what happens when you downcast or match on a value while it is being constructed?</p>

<p>Rust has always sidestepped these questions by using the functional language approach, where you construct an aggregate value (like a struct) by supplying all its data at once. This works good for small structs, but it doesn’t scale up to supporting refinement types and common fields. Consider the example of types in the compiler:</p>

<pre><code>enum TypeData&lt;'tcx&gt; {
    // Common fields:
    id: u32,
    flags: u32,
    counter: usize, // ok, I'm making this field up :P

    ...,
    FnPointer {
        unsafety: Unsafety,
        abi: Abi,
        signature: Signature,
    }
    ..., // other variants here
}

</code></pre>

<p>I would like to be able to write some initialization routines that compute the  <code>id</code>, flags, and whatever else and then reuse those across different variants. But it’s hard to know what such a function should return:</p>

<pre><code>fn init_type_data(cx: &amp;mut Context) -&gt; XXX {
    XXX { id: cx.next_id(), flags: DEFAULT_FLAGS, counter: 0 }
}

</code></pre>

<p>What is this type  <code>XXX</code>? What I want is basically a struct with just the common fields (though of course I don’t want to have to define such a struct mself, too repetitive):</p>

<pre><code>struct XXX {
    id: u32,
    flags: u32,
    counter: usize,
}

</code></pre>

<p>And of course I also want to be able to use an instance of this struct in an initializer as part of a  <code>..</code>expression, like so:</p>

<pre><code>fn make_fn_type(cx: &amp;mut Context, unsafety: Unsafety, abi: Abi, signature: Signature) {
    TypeData::FnPointer {
        unsafety: unsafety,
        abi: abi,
        signature: signature,
        ..init_type_data(cx)   // &lt;-- initializes the common fields 
    }
}

</code></pre>

<p>If we had a type like this, it strikes a reasonable nice balance between the functional and OO styles. We can layer constructors and build constructor abstractions, but we also don’t have a value of type<code>TypeData</code>  until all the fields are initialized. In the interim, we just have a value of this type  <code>XXX</code>, which only has the shared fields that are common to all variants.</p>

<p>All we need now is a reasonable name for this type  <code>XXX</code>. The proposal is that every enum has an associated struct type called  <code>struct</code>  (i.e, the keyword). So instead of  <code>XXX</code>, I could write  <code>TypeData::struct</code>, and it means “a struct with all the fields common to any  <code>TypeData</code>  variant”. Note that a  <code>TypeData::struct</code>  value is  <em>not</em>  a  <code>TypeData</code>  variant; it just has the same data as a variant.</p>

<h3 id="subtyping-and-coercion-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-subtyping-and-coercion">Subtyping and coercion[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#subtyping-and-coercion">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#subtyping-and-coercion</a>)</h3>

<p>There is one final wrinkle worth covering in the proposal. And unfortunately, it’s a tricky one. I’ve been sort of tacitly assuming that an enum and its variants have some sort of typing relationship, but I haven’t said explicitly what it is. This part is going to take some experimentation to find the right mix. But let me share some intermediate thoughts.</p>

<p><strong>Unsized enums.</strong>  For unsized enums, we are always dealing with an indirection. So e.g. we have to be able to smoothly convert from a reference to a specific struct like  <code>&amp;TextElement</code>  to a reference to a base enum like  <code>&amp;Node</code>. We’ve traditionally viewed this as a special case of  <a href="https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md">“DST coercions”</a>. Basically, coercing to  <code>&amp;Node</code>  is more-or-less exactly like coercion to a trait object, except that we don’t in fact need to attach a vtable – that is, the “extra data” on the  <code>&amp;Node</code>  fat pointer is just  <code>()</code>. But in fact we don’t necessarily HAVE to view upcasting like this as a coercion – after all, there is no runtime change happening here.</p>

<p>This gets at an interesting point. Subtyping between OO classes is normally actually subtyping between  <em>references</em>. That is, in Java we say that  <code>String &lt;: Object</code>, but that is because everything in Java is in fact a reference. In C++, not everything is a reference, so if you aren’t careful this in fact gives rise to creepy hazards like  <a href="http://stackoverflow.com/questions/274626/what-is-object-slicing">object slicing</a>. The problem here is that in C++ the superclass type is really just the superclass fields; so if you do  <code>superclass = subclass</code>, then you are just going to drop the extra fields from the subclass on the floor (usually). This probably isn’t what you meant to do.</p>

<p>Because of unsized types, though, Rust can safely say that a struct type is a subtype of its containing enum(s). So, in the DOM example, we could say that  <code>TextElement &lt;: Node</code>. We don’t have to fear slicing because the type  <code>TextElement</code>  is unsized, and hence the user could only ever make use of it by ref. In other words, object slicing arises C++ precisely because it doesn’t have a notion of unsized types.</p>

<p><strong>Sized enums.</strong>  To be honest, unsized enums are not the scary case, because they are basically a new feature to the language. The harder and more interesting case is sized enums. The problem here is that we are introducing new types into existing code, and we want to be sure not to break things. So consider this example:</p>

<pre><code>let mut x = None;
x = Some(3);

</code></pre>

<p>In today’s world, the first assignment gives  <code>x</code>  a type of  <code>Option&lt;_&gt;</code>, where the  <code>_</code>  represents something to be inferred later. This is because the expression  <code>None</code>  has type  <code>Option&lt;_&gt;</code>. But under this RFC, the type of  <code>None</code>  is  <code>None&lt;_&gt;</code>  – and hence we have to be smart enough to infer that the type of  <code>x</code>  should not be  <code>None&lt;_&gt;</code>  but rather  <code>Option&lt;_&gt;</code>  (because it is later assigned a  <code>Some&lt;_&gt;</code>  value).</p>

<p>This kind of inference, where the type of a variable changes based on the full set of values assigned to it, is traditionally what we have called “subtyping” in the Rust compiler. (In contrast, coercion is an instantaneous decision that the compiler makes based on the types it knows thus far.) This is sort of technical minutia in how the compiler works, but of course it impacts the places in Rust that you need type annoations.</p>

<p>Now, to some extent, we already have this problem. There are known cases today where coercions don’t work as well as we would like. The proposed  <code>box</code>  syntax, for example, suffers from this a bit, as do other patterns. We’re investing ways to make the compiler smarter, and it may be that we can combine all of this into a more intelligent inference infrastructure.</p>

<p><strong>Variance and mutable references.</strong>  It’s worth pointing out that we’ll always need some sort of coercion support, because subtyping alone doesn’t allow one to convert between mutable references. In other words,  <code>&amp;mut TextElement</code>  is not a subtype of  <code>&amp;mut Node</code>, but we do need to be able to coercion from the former to the latter. This is safe because the type  <code>Node</code>  is unsized (basically, it is safe for the same reason that  <code>&amp;mut [i32; 3]</code>  -&gt;  <code>&amp;mut [i32]</code>  is safe). The fact that  <code>&amp;mut None&lt;i32&gt;</code>  -&gt;  <code>&amp;mut Option&lt;i32&gt;</code>is  <em>not</em>  safe is an example of why sized enums can in fact be more challenging here. (If it’s not clear why that should be unsafe, the  <a href="https://doc.rust-lang.org/nightly/nomicon/subtyping.html#variance">Nomicon’s section on variance</a>  may help clear things up.)</p>

<h4 id="an-alternative-variation-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-an-alternative-variation">An alternative variation[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#an-alternative-variation">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#an-alternative-variation</a>)</h4>

<p>If, in fact, we can’t solve the subtyping inference problems, there is another option. Rather than unifying enums and structs, we could add struct inheritance and leave enums as they are. Things would work more-or-less the same as in this proposal, but base structs would play the role of unsized enums, and sized enums would stay how they are. This can be justified on the basis that enums are used in different stylistic ways (like  <code>Option</code>  etc) where e.g. refinement types and common fields are less important; however, I do find the setup described in this blog post appealing.</p>

<h4 id="type-parameters-gadts-etc-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-type-parameters-gadts-etc">Type parameters, GADTs, etc[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#type-parameters-gadts-etc">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#type-parameters-gadts-etc</a>)</h4>

<p>One other detail I want to note. At least to start, I anticipate a requirement that every type in the hierarchy has the same set of type parameters (just like an  <code>enum</code>  today). If you use the “inline” syntax, this is implicit, but you’ll have to write it explicitly with the out of line syntax (we could permit reordering, but there should be a 1-to-1 correspondence). This simplifies the type-checker and ensures that this is more of an incremental step in complexity when compared to today’s enums, versus the giant leap we could have otherwise – loosening this rule also interacts with monomorphization and specialization, but I’ll dig into that more another time.</p>

<h3 id="conclusion-http-smallcultfollowing-com-babysteps-blog-2015-08-20-virtual-structs-part-3-bringing-enums-and-structs-together-conclusion">Conclusion[](<a href="http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#conclusion">http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/#conclusion</a>)</h3>

<p>This post describes a proposal for unifying structs and enums to make each of them more powerful. It builds on prior work but adds a few new twists that close important gaps:</p>

<ul>
<li>Enum bounds for type parameters, allowing for smoother interaction with generic code.</li>
<li>The “associated struct” for enums, allowing for constructors.</li>
</ul>

<p>One of the big goals of this design is to find something that fits well within Rust’s orthogonal design. Today, data types like enums and structs are focused on describing data layout and letting you declare natural relationships that mesh well with the semantics of your program. Traits, in contrast, are used to write generic code that works across a heterogeneous range of types. This proposal retains that character, while alleviating some of the pain points in Rust today:</p>

<ul>
<li>Support for refinement types and nested enum hierarchies;</li>
<li>Support for common fields shared across variants;</li>
<li>Unsized enums that allow for more efficient memory layout.</li>
</ul>

<hr />

<p>Virtual Structs Part 4: Extended Enums And Thin Traits
Oct 8, 2015</p>

<p>So, aturon wrote this interesting post on an alternative “virtual structs” approach, and, more-or-less since he wrote it, I’ve been wanting to write up my thoughts. I finally got them down.</p>

<p>Before I go any further, a note on terminology. I will refer to Aaron’s proposal as the Thin Traits proposal, and my own previous proposal as the Extended Enums proposal. Very good.</p>

<p>(OK, I lied, one more note: starting with this post, I’ve decided to disable comments on this blog. There are just too many forums to keep up with! So if you want to discuss this post, I’d recommend doing so on this Rust internals thread.)</p>

<p>Conclusion
Let me lead with my conclusion: while I still want the Extended Enums proposal, I lean towards implementing the Thin Traits proposal now, and returning to something like Extended Enums afterwards (or at some later time). My reasoning is that the Thin Traits proposal can be seen as a design pattern lying latent in the Extended Enums proposal. Basically, once we implement specialization, which I want for a wide variety of reasons, we almost get Thin Traits for free. And the Thin Traits pattern is useful enough that it’s worth taking that extra step.</p>

<p>Now, since the Thin Traits and Extended Enums proposal appear to be alternatives, you may wonder why I would think there is value in potentially implementing both. The way I see it, they target different things. Thin Traits gives you a way to very precisely fashion something that acts like a C++ or Java class. This means you get thin pointers, inherited fields and behavior, and you even get open extensibility (but, note, you thus do not get downcasting).</p>

<p>Extended Enums, in contrast, is targeting the “fixed domain” use case, where you have a defined set of possibilities. This is what we use enums for today, but (for the reasons I outlined before) there are various places that we could improve, and that was what the extended enums proposal was all about. One advantage of targeting the fixed domain use case is that you get additional power, such as the ability to do match statements, or to use inheritance when implementing any trait at all (more details on this last point below).</p>

<p>To put it another way: with Thin Traits, you write virtual methods whereas with Extensible Enums, you write match statements – and I think match statements are far more common in Rust today.</p>

<p>Still, Thin Traits will be a very good fit for various use cases. They are a good fit for Servo, for example, where they can be put to use modeling the DOM. The extensibility here is probably a plus, if not a hard requirement, because it means Servo can spread the DOM across multiple crates. Another place that they might (maybe?) be useful is if we want to have a stable interface to the AST someday (though for that I think I would favor something like RFC 757).</p>

<p>But I think there a bunch of use cases for extensible enums that thin traits don’t cover at all. For example, I don’t see us using thin traits in the compiler very much, nor do I see much of a role for them in LALRPOP, etc. In all these cases, the open-ended extensibility of Thin Traits is not needed and being able to exhaustively match is key. Refinement types would also be very welcome.</p>

<p>Which brings me to my final thought. The Extended Enums proposal, while useful, was not perfect. It had some rough spots we were not happy with (which I’ll discuss later on). Deferring the proposal gives us time to find new solutions to those aspects. Often I find that when I revisit a troublesome feature after letting it sit for some time, I find that either (1) the problem I thought there was no longer bothers me or (2) the feature isn’t that important anyway or (3) there is now a solution that was either previously not possible or which just never occurred to me.</p>

<p>OK, so, with that conclusion out of the way, the post continues by examining some of the rough spots in the Extended Enums proposal, and then looking at how we can address those by taking an approach like the one described in Thin Traits.</p>

<p>Thesis: Extended Enums
Let’s start by reviewing a bit of the Extended Enums proposal. Extended Enums, as you may recall, proposed making types for each of the enum variants, and allowing them to be structured in a hierarchy. It also proposed permitting enums to be declared as “unsized”, which meant that the size of the enum type varies depending on what variant a particular instance is.</p>

<p>In that proposal, I used a syntax where enums could have a list of common fields declared in the body of the enum:</p>

<p>enum TypeData&lt;&lsquo;tcx&gt; {
    // Common fields:
    id: u32,
    flags: u32,
    &hellip;,</p>

<pre><code>// Variants:
Int { },
Uint { },
Ref { referent_ty: Ty&lt;'tcx&gt; },
...
</code></pre>

<p>}
One could also declare the variants out of line, as in this example:</p>

<p>unsized enum Node {
  position: Rectangle, // &lt;&ndash; common fields, but no variants
  &hellip;
}</p>

<p>enum Element: Node {
  &hellip;
}</p>

<p>struct TextElement: Element {
  &hellip;
}</p>

<p>&hellip;
Note that in this model, the “variants”, or leaf nodes in the type hierarchy, are always structs. The inner nodes of the hierarchy (those with children) are enums.</p>

<p>In order to support the abstraction of constructors, the proposal includes a special associated type that lets you pull out a struct containing the common fields from an enum. For example, Node::struct would correspond to a struct like</p>

<p>struct NodeFields {
    position: Rectangle,
    &hellip;
}
Complications with common fields
The original post glossed over certain complications that arise around common fields. Let me outline some of those complications. To start, the associated struct type has always been a bit odd. It’s just an unusual bit of syntax, for one thing. But also, the fact that this struct is not declared by the user raises some thorny questions. For example, are the fields declared as public or private? Can we implement traits for this associated struct type? And so forth.</p>

<p>There are similar questions raised about the common fields in the enum itself. In a struct, fields are private by default, and must be declared as public (even if the struct is public):</p>

<p>pub struct Foo { // the struct is public&hellip;
   f: i32        // &hellip;but its fields are private.
}
But in an enum, variants (and their fields) are public if the enum is public:</p>

<p>pub enum Foo { // the enum is public&hellip;
    Variant1 { f: i32 }, // &hellip;and so are its variants, and their fields.
}
This default matches how enums and structs are typically used: public structs are used to form abstraction barriers, and public enums are exposed in order to allow the outside world to match against the various cases. (We used to make the fields of public structs be public as well, but we found that in practice the overwhelming majority were just declared as private.)</p>

<p>However, these defaults are somewhat problematic for common fields. For example, let’s look at that DOM example again:</p>

<p>unsized pub enum Node {
  position: Rectangle,
  &hellip;
}
This field is declared in an enum, and that enum is public. So should the field position be public or private? I would argue that this enum is more “struct-like” in its usage pattern, and the default should be private. We could arrive at this by adjusting the defaults based on whether the enum declares its variant inline or out of line. I expect this would actually match pretty well with actual usage, but you can see that this is a somewhat subtle rule.</p>

<p>Antithesis: Thin Traits
Now let me pivot for a bit and discuss the Thin Traits proposal. In particular, let’s revisit the DOM hierarchy that we saw before (Node, Element, etc), and see how that gets modeled. In the thin traits proposal, every logical “class” consists of two types. The first is a struct that defines its common fields and the second is a trait that defines any virtual methods. So, the root of a DOM might be a Node type, modeled like so:</p>

<p>struct NodeFields {
    id: u32
}</p>

<p>#[repr(thin)]
trait Node: NodeFields {
    fn something(&amp;self);
    fn something_else(&amp;self);
}
The struct NodeFields here just represents the set of fields that all nodes must have. Because it is declared as a superbound of Node, that means that any type which implements Node must have NodeFields as a prefix. As a result, if we have a &amp;Node object, we can access the fields from NodeFields at no overhead, even without knowing the precise type of the implementor.</p>

<p>(Furthermore, because Node was declared as a thin trait, a &amp;Node pointer can be a thin pointer, and not a fat pointer. This does mean that Node can only be implemented for local types. Note though that you could use this same pattern without declaring Node as a thin trait and it would still work, it’s just that &amp;Node references would be fat pointers.)</p>

<p>The Node trait shown had two virtual methods, something() and something_else(). Using specialization, we can provide a default impl that lets us give some default behavior there, but also allows subclasses to override that behavior:</p>

<p>partial impl<T:Node> Node for T {
    fn something(&amp;self) {
        // Here something_else() is not defined, so it is &ldquo;pure virtual&rdquo;
        self.something_else();
    }
}
Finally, if we have some methods that we would like to dispatch statically on Node, we can do that by using an inherent method:</p>

<p>impl Node {
    fn get_id(&amp;self) -&gt; u32 { self.id }
}
This impl looks similar to the partial impl above, but in fact it is not an impl of the trait Node, but rather adding inherent methods that apply to Node objects. So if we call node.get_id() it doesn’t go through any virtual dispatch at all.</p>

<p>You can continue this pattern to create subclasses. So adding an Element subclass might look like:</p>

<p>struct ElementFields: NodeFields {
  ..
}</p>

<p>#[repr(thin)]
trait Element: Node + ElementFields {
  ..
}
and so forth.</p>

<p>Synthesis: Extended Enums as a superset of Thin Traits
The Thin Traits proposal addresses common fields by creating explicit structs, like NodeFields, that serve as containers for the common fields, and by adding struct inheritance. This is an alternative to the special Node::struct we used in the Extended Enums proposal. There are pros and cons to using struct inheritance over Node::struct. On the pro side, struct inheritance sidesteps the various questions about privacy, visibility, and so forth that arose with Node::struct. On the con side, using structs requires a kind of parallel hierarchy, which is something we were initially trying to avoid. A final advantage for using struct inheritance is that it is a “reusable” mechanism. That is, whereas adding common fields to enums only affects enums, using struct inheritance allows us to add common fields to enums, traits, and other structs. Considering all of these things, it seems like struct inheritance is a better choice.</p>

<p>If we were to convert the DOM example to use struct inheritance, it would mean that an enum may inherit from a struct, in which case it gets the fields of that struct. For out-of-line enum declarations, then, we can simply create an enum with an empty body:</p>

<p>struct NodeFields {
  position: Rectangle, // &lt;&ndash; common fields, but no variants
}</p>

<p>#[repr(unsized)]
enum Node: NodeFields;</p>

<p>struct ElementFields: NodeFields {
  ..
}</p>

<p>enum Element: Node + ElementFields;
(I’ve also taken the liberty of changing from the unsized keyword to an annotation, #[repr(unsized)]. Given that making an enum unsized doesn’t really affect its semantics, just the memory layout, using a #[repr] attribute seems like a good choice. It was something we considered before; I’m not really sure why we rejected it anymore.)</p>

<p>Method dispatch
My post did not cover how virtual method dispatch was going to work. Aaron gave a quick summary in the Thin Trait proposal. I will give an even quicker one here. It was a goal of the proposal that one should be able to use inheritance to refine the behavior over the type hierarchy. That is, one should be able to write a set of impls like the following:</p>

<p>impl<T> MyTrait for Option<T> {
    default fn method1() { &hellip; }
    default fn method2() { &hellip; }
    default fn method3();
}</p>

<p>impl<T> MyTrait for Option::Some<T> {
    fn method1() { /* overrides the version above <em>/ }
    fn method3() { /</em> must be implemented */ }
}</p>

<p>impl<T> MyTrait for Option::None<T> {
    fn method2() { /* overrides the version above <em>/ }
    fn method3() { /</em> must be implemented */ }
}
This still seems like a very nice feature to me. As the Thin Traits proposal showed, specialization makes this kind of refinement possible, but it requires a variety of different impls. The example above, however, didn’t have quite so many impls – why is that?</p>

<p>What we had envisioned to bridge the gap was that we would use a kind of implicit sugar. That is, the impl for Option<T> would effectively be expanded to two impls. One of them, the partial impl, provides the defaults for the variants, and other, a concrete impl, effectively implements the virtual dispatch, by matching and dispatching to the appropriate variant:</p>

<p>// As originally envisioned, <code>impl&lt;T&gt; MyTrait for Option&lt;T&gt;</code>
// would be sugar for the following two impls:</p>

<p>partial impl<T> MyTrait for Option<T> {
    default fn method1() { &hellip; }
    default fn method2() { &hellip; }
    default fn method3();
}</p>

<p>impl<T> MyTrait for Option<T> {
    fn method1(&amp;self) {
        match self {
            this @ &amp;Some(..) =&gt; Option::Some::method1(this),
            this @ &amp;None =&gt; Option::None::method1(this),
        }
    }
    &hellip; // as above, but for the other methods
}
Similar expansions are needed for inherent impls. You may be wondering why it is that we expand the one impl (for Option<T>) into two impls in the first place. Each plays a distinct role:</p>

<p>The partial impl handles the defaults part of the picture. That is, it supplies default impls for the various methods that impls for Some and None can reuse (or override).
The impl itself handles the “virtual” dispatch part of things. We want to ensure that when we call method1() on a variable o of type Option<T>, we invoke the appropriate method1 depending on what variant o actually is at runtime. We do this by matching on o and then delegating to the proper place. If you think about it, this is roughly equivalent to loading a function pointer out of a vtable and dispatching through that, though the performance characteristics are interesting (in a way, it resembles a fully expanded builtin PIC).
Overall, this kind of expansion is a bit subtle. It’d be nice to have a model that did not require it. In fact, in an earlier design, we DID avoid it. We did so by introducing a new shorthand, called match impl. This would basically create the “downcasting” impl that we added implicitly above. This would make the correct pattern as follows:</p>

<p>partial impl<T> MyTrait for Option<T> { // &lt;&ndash; this is now partial
    default fn method1() { &hellip; }
    default fn method2() { &hellip; }
    default fn method3();
}</p>

<p>match impl<T> MyTrait for Option<T>; // &lt;&ndash; this is new</p>

<p>impl<T> MyTrait for Option::Some<T> {
    fn method1() { /* overrides the version above <em>/ }
    fn method3() { /</em> must be implemented */ }
}</p>

<p>impl<T> MyTrait for Option::None<T> {
    fn method2() { /* overrides the version above <em>/ }
    fn method3() { /</em> must be implemented */ }
}
At first glance, this bears a strong resemblance to how the Thin Trait proposal handled virtual dispatch. In the Thin Trait proposal, we have a partial impl as well, and then concrete impls that override the details. However, there is no match impl in Thin Trait proposal. It is not needed because, in that proposal, we were implementing the Node trait for the Node type – and in fact the compiler supplies that impl automatically, as part of the object safety notion.</p>

<p>Expression problem, I know thee well—a serviceable villain
But there is another difference between the two examples, and it’s important. In this code I am showing above, there is in fact no connection between MyTrait and Option. That is, under the Extended Enums proposal, I can implement foreign traits and use inheritance to refine the behavior depending on what variant I have. The Thin Traits pattern, however, only works for implementing the “main” traits (e.g., Node, Element, etc) – and the reason why is because you can’t write “match impls” under the Thin Traits proposal, since the set of types is open-ended. (Instead we lean on the compiler-generated virtual impl of Node for Node, etc.)</p>

<p>What you can do in the Thin Traits proposal is to add methods to the main traits and just delegate to those. So I could do something like:</p>

<p>trait MyTrait {
    fn my_method(&amp;self);
}</p>

<p>&hellip;</p>

<p>trait Node {
    fn my_trait_my_method(&amp;self);
}</p>

<p>impl MyTrait for Node {
    fn my_method(&amp;self) {
        // delegate to the method in the <code>Node</code> trait
        self.my_trait_my_method();
    }
}
Now you can use inheritance to refine the behavior of my_trait_my_method if you like. But note that this only works if the MyTrait type is in the same crate as Node or some ancestor crate.</p>

<p>The reason for this split is precisely the open-ended nature of the Thin Trait pattern. Or, to give this another name, it is the famous expression problem. With Extensible Enums, we enumerated all the cases, so that means that other, downstream crates, can now implement traits against those cases. We’ve fixed the set of cases, but we can extended infinitely the set of operations. In contrast, with Thin Traits, we enumerated the operations (as the contents of the master traits), but we allow downstream crates to implement new cases for those operations.</p>

<p>So method dispatch proves to be pretty interesting:</p>

<p>It gives further evidence that Extensible Enums represent a useful entity in their own right.
It seems like a case where we may find that the tradeoffs change over time. That is, maybe match impl is not such a bad solution after all, particularly if the Thin Trait pattern is covering some share of the “object-like” use cases. In which case one of the main bits of “magic” in the Extensible Enums proposal goes away.
Conclusion
Oh, wait, I already gave it. Well, the most salient points are:</p>

<p>Extensible Enums are about a fixed set of cases, open-ended set of operations. Thin Traits are not. This matters.
Thin Traits are (almost) a “latent pattern” in the Extensible Enums proposal, requiring only #[repr(thin)] and struct inheritance.
Struct inheritance might be nicer than associated structs anyway.
We could consider doing both, and if so, it would probably make sense to implement Specialization, then Thin Traits, and only then consider Extensible Enums.</p>

</div>


    </main>

    
  </body>
</html>
