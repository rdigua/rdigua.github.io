<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.59.0-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title> &middot; Jay Blog</title>

  
  <link type="text/css" rel="stylesheet" href="http://blog.jaytogo.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://blog.jaytogo.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jaytogo.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jaytogo.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.jaytogo.com/"><h1>Jay Blog</h1></a>
      <p class="lead">
       learning rust, reviwe c, erp, javascript, blog, python 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://blog.jaytogo.com/">Home</a> </li>
        <li><a href="/rust/"> rust </a></li>
      </ul>
    </nav>

    <p>&copy; 2019. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1></h1>
  <time datetime=0001-01-01T00:00:00Z class="post-date">Mon, Jan 1, 0001</time>
  

<h1 id="rusté”™è¯¯å¤„ç†">Rusté”™è¯¯å¤„ç†</h1>

<p>From: <a href="https://zhuanlan.zhihu.com/p/52373731">Rusté”™è¯¯å¤„ç†</a>
<a href="https://www.zhihu.com/people/krriy"><img src="https://pic3.zhimg.com/v2-1e2b6d207207f132b4acfec15d5ceadf_xs.jpg" alt="krircc" /></a></p>

<p><a href="https://www.zhihu.com/people/krriy">krircc</a></p>

<p>å¤©çœŸ-æµªæ¼«</p>

<p>11 äººèµåŒäº†è¯¥æ–‡ç« </p>

<h2 id="rusté”™è¯¯å¤„ç†-1">Rusté”™è¯¯å¤„ç†</h2>

<blockquote>
<p>æœ¬æ–‡åŒæ­¥äº<a href="https://link.zhihu.com/?target=https%3A//rustlang-cn.org/read/rust/2018/rust-error-handle.html">Rustä¸­æ–‡ç¤¾åŒºä¸“æ æ–‡ç« ï¼šRusté”™è¯¯å¤„ç†</a>  ,æœ¬æ–‡æ—¶é—´ï¼š2018-12-14, è¯‘è€…ï¼š<a href="https://link.zhihu.com/?target=https%3A//krircc.github.io/">krircc</a>ï¼Œç®€ä»‹ï¼šå¤©é’è‰²ï¼Œ<a href="https://link.zhihu.com/?target=https%3A//medium.com/learning-rust/rust-error-handling-72a8e036dd3">åŸæ–‡å‡ºå¤„</a></p>
</blockquote>

<p><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/rustlang-cn/Important/issues/1">æ¬¢è¿åŠ å…¥</a></strong>Rustä¸­æ–‡ç¤¾åŒº,å…±å»ºRustè¯­è¨€ä¸­æ–‡ç½‘ç»œï¼æ¬¢è¿å‘Rustä¸­æ–‡ç¤¾åŒºä¸“æ æŠ•ç¨¿,<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/rustlang-cn/rustlang-cn">æŠ•ç¨¿åœ°å€</a></strong>  ,å¥½æ–‡åœ¨ä»¥ä¸‹åœ°æ–¹ç›´æ¥å±•ç¤º, æ¬¢è¿è®¿é—®<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/rustlang-cn/forum/issues">Rustä¸­æ–‡è®ºå›</a></strong>ï¼ŒQQç¾¤ï¼š<strong>570065685</strong></p>

<ol>
<li><p><strong><a href="https://link.zhihu.com/?target=https%3A//rustlang-cn.org/">Rustä¸­æ–‡ç¤¾åŒºé¦–é¡µ</a></strong></p></li>

<li><p>Rustä¸­æ–‡ç¤¾åŒº<a href="https://link.zhihu.com/?target=https%3A//rustlang-cn.org/read/rust/">ä¸“æ æ–‡ç« </a></p></li>
</ol>

<h2 id="æ™ºèƒ½ç¼–è¯‘å™¨">æ™ºèƒ½ç¼–è¯‘å™¨</h2>

<p>Rustç¼–è¯‘å™¨æœ€é‡è¦çš„å·¥ä½œæ˜¯é˜²æ­¢Rustç¨‹åºä¸­çš„é”™è¯¯ã€‚å¦‚æœä»£ç æ²¡æœ‰æ­£ç¡®éµå¾ªå†…å­˜ç®¡ç†è§„åˆ™æˆ–ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šï¼Œå®ƒä¼šåœ¨ç¼–è¯‘æ—¶åˆ†æä»£ç å¹¶å‘å‡ºè­¦å‘Šã€‚ä¾‹å¦‚ï¼Œ</p>

<pre><code class="language-rust">#[allow(unused_variables)] //ğŸ’¡ A lint attribute used to suppress the warning; unused variable: `b`
fn main() {
    let a = vec![1, 2, 3];
    let b = a;

    println!(&quot;{:?}&quot;, a);
}


// ------ Compile time error ------
error[E0382]: use of moved value: `a`
 --&gt; src/main.rs:6:22
  |
3 |     let b = a;
  |         - value moved here
4 |
5 |     println!(&quot;{:?}&quot;, a);
  |                      ^ value used here after move
  |
  = note: move occurs because `a` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait

error: aborting due to previous error
For more information about this error, try `rustc --explain E0382`.

// â­ instead using #[allow(unused_variables)], consider using &quot;let _b = a;&quot; in line 4. 
// Also you can use &quot;let _ =&quot; to completely ignore return values

</code></pre>

<p>Rustç¼–è¯‘å™¨ä¸ä»…æ£€æŸ¥ä¸ç”Ÿå‘½å‘¨æœŸæˆ–å†…å­˜ç®¡ç†ç›¸å…³çš„é—®é¢˜ï¼Œè¿˜æ£€æŸ¥å¸¸è§çš„ç¼–ç é”™è¯¯ï¼Œå¦‚ä¸‹é¢çš„ä»£ç ã€‚</p>

<pre><code class="language-rust">struct Color {
    r: u8,
    g: u8,
    b: u8,
}

fn main() {
    let yellow = Color {
        r: 255,
        g: 255,
        d: 0,
    };

    println!(&quot;Yellow = rgb({},{},{})&quot;, yellow.r, yellow.g, yellow.b);
}


// ------------ Compile time error ------------
error[E0560]: struct `Color` has no field named `d`
  --&gt; src/main.rs:11:9
   |
11 |         d: 0,
   |         ^ field does not exist - did you mean `b`?

error: aborting due to previous error
For more information about this error, try `rustc --explain E0560`.

</code></pre>

<p>ä»¥ä¸Šé”™è¯¯æ¶ˆæ¯éå¸¸å…·æœ‰æè¿°æ€§ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°çœ‹å‡ºé”™è¯¯åœ¨å“ªé‡Œã€‚ä½†æ˜¯ï¼Œè™½ç„¶æˆ‘ä»¬æ— æ³•é€šè¿‡é”™è¯¯æ¶ˆæ¯è¯†åˆ«é—®é¢˜ï¼Œä½†<code>rustc --explain</code>  å‘½ä»¤é€šè¿‡æ˜¾ç¤ºè¡¨è¾¾ç›¸åŒé—®é¢˜çš„ç®€å•ä»£ç ç¤ºä¾‹ä»¥åŠæˆ‘ä»¬å¿…é¡»ä½¿ç”¨çš„è§£å†³æ–¹æ¡ˆæ¥å¸®åŠ©æˆ‘ä»¬<strong>è¯†åˆ«é”™è¯¯ç±»å‹ä»¥åŠå¦‚ä½•è§£å†³å®ƒ</strong>ã€‚ä¾‹å¦‚ï¼Œåœ¨æ§åˆ¶å°ä¸­æ˜¾ç¤ºä»¥ä¸‹è¾“å‡ºã€‚<code>rustc --explain E0571</code></p>

<pre><code class="language-rust">// A `break` statement with an argument appeared in a non-`loop` loop.

// Example of erroneous code:

let result = while true {
    if satisfied(i) {
        break 2*i; // error: `break` with value from a `while` loop
    }
    i += 1;
};

// The `break` statement can take an argument (which will be the value of the loop expression if the `break` statement is executed) in `loop` loops, but not `for`, `while`, or `while let` loops.

Make sure `break value;` statements only occur in `loop` loops:
let result = loop { // ok!
    if satisfied(i) {
        break 2*i;
    }
    i += 1;
};

</code></pre>

<p>ğŸ’¡æ‚¨ä¹Ÿå¯ä»¥é€šè¿‡<code>Rust Compiler Error Index</code>é˜…è¯»ç›¸åŒçš„è§£é‡Š ã€‚ä¾‹å¦‚ï¼Œè¦æ£€æŸ¥<code>E0571</code>é”™è¯¯çš„è§£é‡Šï¼Œæ‚¨å¯ä»¥ä½¿ç”¨<code>https://doc.rust-lang.org/error-index.html#E0571</code></p>

<h2 id="panicking">Panicking</h2>

<h2 id="panic">panic!()</h2>

<p>â–¸ åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå½“å‘ç”Ÿé”™è¯¯æ—¶ï¼Œæˆ‘ä»¬æ— æ³•åšä»»ä½•äº‹æƒ…æ¥å¤„ç†å®ƒï¼Œå¦‚æœé”™è¯¯æ˜¯æŸç§æƒ…å†µï¼Œé‚£å°±ä¸åº”è¯¥å‘ç”Ÿã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœè¿™æ˜¯ä¸€ä¸ªä¸å¯æ¢å¤çš„é”™è¯¯ã€‚</p>

<p>â–¸ å½“æˆ‘ä»¬ä¸ä½¿ç”¨åŠŸèƒ½ä¸°å¯Œçš„è°ƒè¯•å™¨æˆ–æ­£ç¡®çš„æ—¥å¿—æ—¶ï¼Œæœ‰æ—¶æˆ‘ä»¬éœ€è¦é€šè¿‡æ‰“å°ç‰¹å®šçš„æ¶ˆæ¯æˆ–å˜é‡ç»‘å®šçš„å€¼ä»ç‰¹å®šçš„ä»£ç è¡Œé€€å‡ºç¨‹åºæ¥è°ƒè¯•ä»£ç ä»¥äº†è§£å½“å‰çš„ç¨‹åºçš„æµç¨‹ã€‚</p>

<p>å¯¹äºä¸Šè¿°æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>panic!</code>å®ã€‚è®©æˆ‘ä»¬çœ‹å‡ ä¸ªä¾‹å­ã€‚</p>

<blockquote>
<p>â­  <code>panic!()</code>  è¿è¡ŒåŸºäºçº¿ç¨‹ã€‚ä¸€ä¸ªçº¿ç¨‹å¯èƒ½ä¼šè¢«ææ…Œï¼Œè€Œå…¶ä»–çº¿ç¨‹æ­£åœ¨è¿è¡Œã€‚</p>
</blockquote>

<p>01.ä»ç‰¹å®šè¡Œé€€å‡ºã€‚</p>

<pre><code class="language-rust">fn main() {
    // some code

    // if we need to debug in here
    panic!();
}

// -------------- Compile time error --------------
thread 'main' panicked at 'explicit panic', src/main.rs:5:5

</code></pre>

<p>02.é€€å‡ºå¹¶æ˜¾ç¤ºè‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯ã€‚</p>

<pre><code class="language-rust">#[allow(unused_mut)] // ğŸ’¡ A lint attribute used to suppress the warning; username variable does not need to be mutable
fn main() {
    let mut username = String::new();

    // some code to get the name

    if username.is_empty() {
        panic!(&quot;Username is empty!&quot;);
    }

    println!(&quot;{}&quot;, username);
}

// -------------- Compile time error --------------
thread 'main' panicked at 'Username is empty!', src/main.rs:8:9

</code></pre>

<p>03.é€€å‡ºé™„å¸¦ä»£ç å…ƒç´ çš„å€¼ã€‚</p>

<pre><code class="language-rust">#[derive(Debug)] // ğŸ’¡ A lint attribute which use to implement `std::fmt::Debug` to Color
struct Color {
    r: u8,
    g: u8,
    b: u8,
}

#[allow(unreachable_code)] // ğŸ’¡ A lint attribute used to suppress the warning; unreachable statement
fn main() {
    let some_color: Color;

    // some code to get the color. ex
    some_color = Color {r: 255, g: 255, b: 0};

    // if we need to debug in here
    panic!(&quot;{:?}&quot;, some_color);

    println!(
        &quot;The color = rgb({},{},{})&quot;,
        some_color.r, some_color.g, some_color.b
    );
}

// -------------- Compile time error --------------
thread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:16:5

</code></pre>

<p>æ­£å¦‚æ‚¨åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­æ‰€çœ‹åˆ°çš„ï¼Œ<code>panic!()</code>æ”¯æŒ<code>println!()</code>ç±»å‹æ ·å¼å‚æ•° ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒä¼šè¾“å‡ºé”™è¯¯æ¶ˆæ¯ï¼Œæ–‡ä»¶è·¯å¾„ä»¥åŠå‘ç”Ÿé”™è¯¯çš„è¡Œå·å’Œåˆ—å·ã€‚</p>

<h2 id="unimplemented">unimplemented!()</h2>

<p>å¦‚æœæ‚¨çš„ä»£ç å…·æœ‰æœªå®Œæˆçš„ä»£ç æ®µï¼Œåˆ™æœ‰ä¸€ä¸ªæ ‡å‡†åŒ–å®<code>unimplemented!()</code>æ¥æ ‡è®°è¿™äº›è·¯å¾„ã€‚å¦‚æœç¨‹åºé€šè¿‡è¿™äº›è·¯å¾„è¿è¡Œï¼Œç¨‹åºå°†<code>panicked</code>å¹¶è¿”å›&rdquo;not yet implemented&rdquo;çš„é”™è¯¯æ¶ˆæ¯ã€‚</p>

<pre><code class="language-rust">// error messages with panic!()
thread 'main' panicked at 'explicit panic', src/main.rs:6:5
thread 'main' panicked at 'Username is empty!', src/main.rs:9:9
thread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5

// error messages with unimplemented!()
thread 'main' panicked at 'not yet implemented', src/main.rs:6:5
thread 'main' panicked at 'not yet implemented: Username is empty!', src/main.rs:9:9
thread 'main' panicked at 'not yet implemented: Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5

</code></pre>

<h2 id="unreachable">unreachable!()</h2>

<p>è¿™æ˜¯æ ‡è®°ç¨‹åºä¸åº”è¾“å…¥çš„è·¯å¾„çš„æ ‡å‡†å®ã€‚å¦‚æœç¨‹åºè¿›å…¥è¿™äº›è·¯å¾„ï¼Œç¨‹åºå°†<code>panicked</code>å¹¶è¿”å›&rdquo;&lsquo;internal error: entered unreachable code&rsquo;&ldquo;é”™è¯¯æ¶ˆæ¯ã€‚</p>

<pre><code class="language-rust">fn main() {
    let level = 22;
    let stage = match level {
        1...5 =&gt; &quot;beginner&quot;,
        6...10 =&gt; &quot;intermediate&quot;,
        11...20 =&gt; &quot;expert&quot;,
        _ =&gt; unreachable!(),
    };

    println!(&quot;{}&quot;, stage);
}


// -------------- Compile time error --------------
thread 'main' panicked at 'internal error: entered unreachable code', src/main.rs:7:20

</code></pre>

<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºæ­¤è®¾ç½®è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯ã€‚</p>

<pre><code class="language-rust">// --- with a custom message ---
_ =&gt; unreachable!(&quot;Custom message&quot;),
// -------------- Compile time error --------------
thread 'main' panicked at 'internal error: entered unreachable code: Custom message', src/main.rs:7:20


// --- with debug data ---
_ =&gt; unreachable!(&quot;level is {}&quot;, level),
// -------------- Compile time error --------------
thread 'main' panicked at 'internal error: entered unreachable code: level is 22', src/main.rs:7:14

</code></pre>

<h2 id="assert-assert-eq-assert-ne">assert!(), assert_eq!(), assert_ne!()</h2>

<p>è¿™äº›æ˜¯æ ‡å‡†å®ï¼Œé€šå¸¸ä¸æµ‹è¯•æ–­è¨€ä¸€èµ·ä½¿ç”¨ã€‚</p>

<ul>
<li><p>assert!()ç¡®ä¿å¸ƒå°”è¡¨è¾¾å¼ä¸ºtrueã€‚å¦‚æœè¡¨è¾¾å¼ä¸ºfalseï¼Œåˆ™ä¼šå‘ç”Ÿ<code>panics</code>ã€‚</p>

<pre><code class="language-rust">fn main() {
let f = false;

assert!(f)
}


// -------------- Compile time error --------------
thread 'main' panicked at 'assertion failed: f', src/main.rs:4:5

</code></pre></li>

<li><p>assert_eq!()ç¡®ä¿ä¸¤ä¸ªè¡¨è¾¾å¼ç›¸ç­‰ã€‚å¦‚æœè¡¨è¾¾å¼ä¸ç›¸ç­‰åˆ™ä¼šå‘ç”Ÿ<code>panics</code>ã€‚</p>

<pre><code class="language-rust">fn main() {
let a = 10;
let b = 20;

assert_eq!(a, b);
}


// -------------- Compile time error --------------
thread 'main' panicked at 'assertion failed: `(left == right)`
left: `10`,
right: `20`', src/main.rs:5:5

</code></pre></li>

<li><p>assert_ne!()ç¡®ä¿ä¸¤ä¸ªè¡¨è¾¾å¼ä¸ç›¸ç­‰ã€‚å¦‚æœè¡¨è¾¾å¼ç›¸ç­‰ï¼Œå®ƒä¼šå‘ç”Ÿ<code>panics</code>ã€‚</p>

<pre><code class="language-rust">fn main() {
let a = 10;
let b = 10;

assert_ne!(a, b);
}


// -------------- Compile time error --------------
thread 'main' panicked at 'assertion failed: `(left != right)`
left: `10`,
right: `10`', src/main.rs:5:5

</code></pre></li>
</ul>

<blockquote>
<p>â­ä½¿ç”¨è¡¨è¾¾å¼assert_ne!()å’Œassert_eq!()åº”è¿”å›ç›¸åŒçš„æ•°æ®ç±»å‹ã€‚</p>
</blockquote>

<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºè¿™äº›å®è®¾ç½®è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯ã€‚ä¸¾äº›ä¾‹å­ï¼Œ</p>

<ol>
<li><p>å¸¦æœ‰è‡ªå®šä¹‰æ¶ˆæ¯ assert_eq!()</p>

<pre><code class="language-rust">fn main() {
let a = 10;
let b = 20;

assert_eq!(a, b, &quot;a and b should be equal&quot;);
}


// -------------- Compile time error --------------
thread 'main' panicked at 'assertion failed: `(left == right)`
left: `10`,
right: `20`: a and b should be equal', src/main.rs:5:5

</code></pre></li>

<li><p>assert_eq!()å¸¦æœ‰è°ƒè¯•æ•°æ®</p>

<pre><code class="language-rust">fn main() {
let a = 10;
let b = 20;

let c = 40;

assert_eq!(a+b, c, &quot;a = {} ; b = {}&quot;, a, b);
}

// -------------- Compile time error --------------
thread 'main' panicked at 'assertion failed: `(left == right)`
left: `30`,
right: `40`: a = 10 ; b = 20', src/main.rs:7:5

</code></pre></li>
</ol>

<h2 id="debug-assert-debug-assert-eq-debug-assert-ne">debug_assert!(), debug_assert_eq!(), debug_assert_ne!()</h2>

<p>ğŸ”è¿™äº›ä¸ä¸Šé¢çš„<code>assert</code>å®ç±»ä¼¼ã€‚ä½†é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™äº›è¯­å¥ä»…åœ¨éä¼˜åŒ–æ„å»ºä¸­å¯ç”¨ã€‚<code>debug_assert</code>é™¤éæˆ‘ä»¬ä¼ é€’<code>-C debug-assertions</code>ç»™ç¼–è¯‘å™¨ï¼Œå¦åˆ™åœ¨å‘å¸ƒç‰ˆæœ¬ä¸­å°†çœç•¥æ‰€æœ‰è¿™äº›å®ã€‚</p>

<h2 id="option-and-result">Option and Result</h2>

<p>è®¸å¤šè¯­è¨€ä½¿ç”¨<code>null\ nil\ undefined</code>  ç±»å‹æ¥è¡¨ç¤ºç©ºè¾“å‡ºå’ŒExceptionså¤„ç†é”™è¯¯ã€‚Rustä¼šåŒæ—¶ä½¿ç”¨ä¸¤è€…ï¼Œç‰¹åˆ«æ˜¯ä¸ºäº†é˜²æ­¢è¯¸å¦‚ç©ºæŒ‡é’ˆå¼‚å¸¸ï¼Œå¼‚å¸¸ç­‰æ•æ„Ÿæ•°æ®æ³„æ¼ç­‰é—®é¢˜ã€‚ç›¸åï¼ŒRustæä¾›äº†ä¸¤ä¸ªç‰¹æ®Šçš„é€šç”¨æšä¸¾ ;  <code>Option</code>å’Œ<code>Result</code>å¤„ç†ä¸Šè¿°æ¡ˆä»¶ã€‚</p>

<p>å¦‚æ‚¨æ‰€çŸ¥:</p>

<p>â–¸  <code>Option</code>å¯ä»¥åŒ…å«æŸä¸ªå€¼<code>Some</code>æˆ–æ²¡æœ‰å€¼/<code>None</code>ã€‚</p>

<p>â–¸  <code>Result</code>å¯ä»¥è¡¨ç¤ºæˆåŠŸ/<code>Ok</code>  æˆ–å¤±è´¥/<code>Err</code>ã€‚</p>

<pre><code class="language-rust">// An output can have either Some value or no value/ None.
enum Option&lt;T&gt; { // T is a generic and it can contain any type of value.
    Some(T),
    None,
}

// A result can represent either success/ Ok or failure/ Err.
enum Result&lt;T, E&gt; { // T and E are generics. T can contain any type of value, E can be any error.
    Ok(T),
    Err(E),
}

</code></pre>

<h2 id="option-çš„åŸºæœ¬ç”¨æ³•"><code>Option</code>çš„åŸºæœ¬ç”¨æ³•</h2>

<p>ç¼–å†™å‡½æ•°æˆ–æ•°æ®ç±»å‹æ—¶:<br />
- å¦‚æœå‡½æ•°çš„å‚æ•°æ˜¯å¯é€‰çš„ï¼Œ - å¦‚æœå‡½æ•°ä¸ºéç©ºï¼Œå¹¶ä¸”è¿”å›çš„è¾“å‡ºå¯ä»¥ä¸ºç©ºï¼Œ - å¦‚æœæ•°æ®ç±»å‹çš„å±æ€§çš„å€¼å¯ä»¥æ˜¯ç©ºï¼Œæˆ‘ä»¬ä¸å¾—ä¸ä½¿ç”¨ä»–ä»¬çš„æ•°æ®ç±»å‹ä¸ºOptionç±»å‹</p>

<p>ä¾‹å¦‚ï¼Œå¦‚æœå‡½æ•°è¾“å‡ºä¸€ä¸ª<code>&amp;str</code>å€¼å¹¶ä¸”è¾“å‡ºå¯ä»¥ä¸ºç©ºï¼Œåˆ™å‡½æ•°çš„è¿”å›ç±»å‹åº”è®¾ç½®ä¸º<code>Option&lt;&amp;str&gt;</code></p>

<pre><code class="language-rust">fn get_an_optional_value() -&gt; Option&lt;&amp;str&gt; {

    //if the optional value is not empty
    return Some(&quot;Some value&quot;);

    //else
    None
}

</code></pre>

<p>åŒæ ·ï¼Œå¦‚æœæ•°æ®ç±»å‹çš„å±æ€§å€¼å¯ä»¥ä¸ºç©ºæˆ–è€…åƒä¸‹é¢ç¤ºä¾‹ä¸­<code>middle_name</code>çš„<code>Name</code>æ•°æ®ç±»å‹é‚£æ ·å¯é€‰ï¼Œæˆ‘ä»¬åº”è¯¥å°†å…¶æ•°æ®ç±»å‹è®¾ç½®ä¸º<code>Option</code>ç±»å‹ã€‚</p>

<pre><code class="language-rust">struct Name {
  first_name: String,
  middle_name: Option&lt;String&gt;, // middle_name can be empty
  last_name: String,
}

</code></pre>

<p>ğŸ’­å¦‚æ‚¨æ‰€çŸ¥ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…<code>match</code>æ¥æ•è·ç›¸å…³çš„è¿”å›ç±»å‹<code>ï¼ˆSome/ Noneï¼‰</code>  ã€‚æœ‰ä¸€ä¸ªå‡½æ•°æ¥è·å–å½“å‰ç”¨æˆ·çš„ä¸»ç›®å½•åœ¨<code>std::env</code>ä¸º<code>home_dir()</code>  ã€‚ç”±äºæ‰€æœ‰ç”¨æˆ·åœ¨Linuxç­‰ç³»ç»Ÿä¸­éƒ½æ²¡æœ‰ä¸»ç›®å½•ï¼Œå› æ­¤ç”¨æˆ·çš„ä¸»ç›®å½•å¯ä»¥æ˜¯å¯é€‰çš„ã€‚æ‰€ä»¥å®ƒè¿”å›ä¸€ä¸ª<code>Option</code>ç±»å‹;<code>Option&lt;PathBuf&amp;</code>amp;gt;.</p>

<pre><code class="language-rust">use std::env;

fn main() {
    let home_path = env::home_dir();
    match home_path {
        Some(p) =&gt; println!(&quot;{:?}&quot;, p), // This prints &quot;/root&quot;, if you run this in Rust playground
        None =&gt; println!(&quot;Can not find the home directory!&quot;),
    }
}

</code></pre>

<p>â­ä½†æ˜¯ï¼Œå½“åœ¨å‡½æ•°ä¸­ä½¿ç”¨å¯é€‰å‚æ•°æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»Noneåœ¨è°ƒç”¨å‡½æ•°æ—¶ä¼ é€’ç©ºå‚æ•°çš„å€¼ã€‚</p>

<pre><code class="language-rust">fn get_full_name(fname: &amp;str, lname: &amp;str, mname: Option&lt;&amp;str&gt;) -&gt; String { // middle name can be empty
  match mname {
    Some(n) =&gt; format!(&quot;{} {} {}&quot;, fname, n, lname),
    None =&gt; format!(&quot;{} {}&quot;, fname, lname),
  }
}

fn main() {
  println!(&quot;{}&quot;, get_full_name(&quot;Galileo&quot;, &quot;Galilei&quot;, None));
  println!(&quot;{}&quot;, get_full_name(&quot;Leonardo&quot;, &quot;Vinci&quot;, Some(&quot;Da&quot;)));
}

// ğŸ’¡ Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()

</code></pre>

<blockquote>
<p>ğŸ”é™¤æ­¤ä¹‹å¤–ï¼Œ<code>Option</code>ç±»å‹ä¸Rustä¸­çš„å¯ç©ºæŒ‡é’ˆä¸€èµ·ä½¿ç”¨ã€‚ç”±äºRustä¸­æ²¡æœ‰ç©ºæŒ‡é’ˆï¼Œå› æ­¤æŒ‡é’ˆç±»å‹åº”æŒ‡å‘æœ‰æ•ˆä½ç½®ã€‚å› æ­¤ï¼Œå¦‚æœæŒ‡é’ˆå¯ä»¥ä¸ºç©ºï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨äº†<code>Option&lt;Box&lt;T&gt;&amp;</code>amp;gt; ã€‚</p>
</blockquote>

<h2 id="result-çš„åŸºæœ¬ç”¨æ³•"><code>Result</code>çš„åŸºæœ¬ç”¨æ³•</h2>

<p>å¦‚æœå‡½æ•°å¯ä»¥äº§ç”Ÿé”™è¯¯ï¼Œæˆ‘ä»¬å¿…é¡»<code>Result</code>é€šè¿‡ç»„åˆæœ‰æ•ˆè¾“å‡ºçš„æ•°æ®ç±»å‹å’Œé”™è¯¯çš„æ•°æ®ç±»å‹æ¥ä½¿ç”¨ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæœ‰æ•ˆè¾“å‡ºçš„æ•°æ®ç±»å‹ä¸º<code>u64</code>ä¸”é”™è¯¯ç±»å‹ä¸º<code>String</code>  ï¼Œåˆ™è¿”å›ç±»å‹åº”ä¸º<code>Result&lt;u64, String&gt;</code>  ã€‚</p>

<pre><code class="language-rust">fn function_with_error() -&gt; Result&lt;u64, String&gt; {

    //if error happens
    return Err(&quot;The error message&quot;.to_string());

    // else, return valid output
    Ok(255)
}

</code></pre>

<p>ğŸ’­å¦‚æ‚¨æ‰€çŸ¥ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…<code>match</code>æ¥æ•è·ç›¸å…³çš„è¿”å›ç±»å‹<code>ï¼ˆOk/ Errï¼‰</code>ã€‚æœ‰ä¸€ä¸ªå‡½æ•°å¯ä»¥è·å–<code>std::env</code>  ä»»ä½•ç¯å¢ƒå˜é‡ä¸­çš„å€¼æ˜¯<code>var()</code>  ã€‚å®ƒçš„è¾“å…¥æ˜¯ç¯å¢ƒå˜é‡åç§°ã€‚å¦‚æœæˆ‘ä»¬ä¼ é€’äº†é”™è¯¯çš„ç¯å¢ƒå˜é‡ï¼Œæˆ–è€…ç¨‹åºåœ¨è¿è¡Œæ—¶æ— æ³•æå–ç¯å¢ƒå˜é‡çš„å€¼ï¼Œåˆ™ä¼šäº§ç”Ÿé”™è¯¯ã€‚æ‰€ä»¥å®ƒçš„è¿”å›ç±»å‹æ˜¯ä¸€ç§<code>Result</code>ç±»å‹;  <code>Result&lt;String, VarError&amp;</code>amp;gt;.</p>

<pre><code class="language-rust">use std::env;

fn main() {
    let key = &quot;HOME&quot;;
    match env::var(key) {
        Ok(v) =&gt; println!(&quot;{}&quot;, v), // This prints &quot;/root&quot;, if you run this in Rust playground
        Err(e) =&gt; println!(&quot;{}&quot;, e), // This prints &quot;environment variable not found&quot;, if you give a nonexistent environment variable
    }
}

</code></pre>

<h2 id="is-some-is-none-is-ok-is-err">is_some(), is_none(), is_ok(), is_err()</h2>

<p>é™¤äº†<code>match</code>è¡¨æƒ…ï¼Œrustè¿˜æä¾›<code>is_some()</code>  ï¼Œ<code>is_none()</code>å¹¶ä¸”<code>is_ok()</code>  ï¼Œ<code>is_err()</code>åŠŸèƒ½ï¼Œä»¥ç¡®å®šè¿”å›ç±»å‹ã€‚</p>

<pre><code class="language-rust">fn main() {
    let x: Option&lt;&amp;str&gt; = Some(&quot;Hello, world!&quot;);
    assert_eq!(x.is_some(), true);
    assert_eq!(x.is_none(), false);

    let y: Result&lt;i8, &amp;str&gt; = Ok(10);
    assert_eq!(y.is_ok(), true);
    assert_eq!(y.is_err(), false);
}

</code></pre>

<h2 id="ok-err-for-result-types">ok(), err() for Result types</h2>

<p>rustå¦å¤–æä¾›<code>ok()</code>å’Œ<code>err()</code>ä¸º<code>Result</code>ç±»å‹ã€‚å®ƒä»¬å°†<code>Result</code>ç±»å‹çš„<code>Ok&lt;T&gt;</code>å€¼å’Œ<code>Err&lt;E&gt;</code>å€¼è½¬æ¢ä¸ºOptionç±»å‹ã€‚</p>

<pre><code class="language-rust">fn main() {
    let o: Result&lt;i8, &amp;str&gt; = Ok(8);
    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;message&quot;);

    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)
    assert_eq!(e.ok(), None);    // Err(v) ok = None

    assert_eq!(o.err(), None);            // Ok(v) err = None
    assert_eq!(e.err(), Some(&quot;message&quot;)); // Err(v) err = Some(v)
}

</code></pre>

<h2 id="unwrap-and-expect">Unwrap and Expect</h2>

<h2 id="unwrap">unwrap()</h2>

<p>â–¸å¦‚æœ<code>Option</code>ç±»å‹å…·æœ‰<code>Some</code>å€¼æˆ–<code>Result</code>ç±»å‹å…·æœ‰<code>Ok</code>å€¼ï¼Œåˆ™å…¶ä¸­çš„å€¼å°†ä¼ é€’åˆ°ä¸‹ä¸€æ­¥ã€‚</p>

<p>â–¸å¦‚æœ<code>Option</code>ç±»å‹å…·æœ‰<code>None</code>å€¼æˆ–<code>Result</code>ç±»å‹å…·æœ‰<code>Err</code>å€¼ï¼Œåˆ™ç¼–ç¨‹<code>panics</code>  ; å¦‚æœErrï¼Œ<code>panics</code>æºå¸¦é”™è¯¯æ¶ˆæ¯ã€‚</p>

<p>è¯¥åŠŸèƒ½ä¸ä»¥ä¸‹ä»£ç ç±»ä¼¼ï¼Œä½¿ç”¨<code>match</code>è€Œä¸æ˜¯ä½¿ç”¨<code>unwrap()</code>  ã€‚</p>

<p>ç¤ºä¾‹ä½¿ç”¨<code>Option</code>å’Œ<code>match</code></p>

<pre><code class="language-rust">fn main() {
    let x;
    match get_an_optional_value() {
        Some(v) =&gt; x = v, // if Some(&quot;abc&quot;), set x to &quot;abc&quot;
        None =&gt; panic!(), // if None, panic without any message
    }

    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 14 `false` to `true`
}

fn get_an_optional_value() -&gt; Option&lt;&amp;'static str&gt; {

    //if the optional value is not empty
    if false {
        return Some(&quot;abc&quot;);
    }

    //else
    None
}


// --------------- Compile time error ---------------
thread 'main' panicked at 'explicit panic', src/main.rs:5:17

</code></pre>

<p>ç¤ºä¾‹ä½¿ç”¨<code>Result</code>å’Œ<code>match</code></p>

<pre><code class="language-rust">fn main() {
    let x;
    match function_with_error() {
        Ok(v) =&gt; x = v, // if Ok(255), set x to 255
        Err(e) =&gt; panic!(e), // if Err(&quot;some message&quot;), panic with error message &quot;some message&quot;
    }

    println!(&quot;{}&quot;, x); // 255 ; if you change line 13 `true` to `false`
}

fn function_with_error() -&gt; Result&lt;u64, String&gt; {
    //if error happens
    if true {
        return Err(&quot;some message&quot;.to_string());
    }

    // else, return valid output
    Ok(255)
}


// ---------- Compile time error ----------
thread 'main' panicked at 'some message', src/main.rs:5:19

</code></pre>

<p>ä¸Šè¿°mainå‡½æ•°ä¸­çš„ç›¸åŒä»£ç å¯ä»¥ä½¿ç”¨<code>unwrap()</code>ä¸¤è¡Œæ¥ç¼–å†™ã€‚</p>

<pre><code class="language-rust">// 01. unwrap error message for None
fn main() {
    let x = get_an_optional_value().unwrap();

    println!(&quot;{}&quot;, x);
}

// --------------- Compile time error ---------------
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', libcore/option.rs:345:21


// 02. unwrap error message for Err
fn main() {
    let x = function_with_error().unwrap();

    println!(&quot;{}&quot;, x);
}

// --------------- Compile time error ---------------
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: &quot;some message&quot;', libcore/result.rs:945:5

</code></pre>

<p>â­ä½†æ˜¯æ­£å¦‚æ‚¨æ‰€çœ‹åˆ°çš„ï¼Œå½“ä½¿ç”¨<code>unwrap()</code>é”™è¯¯æ¶ˆæ¯æ—¶ï¼Œæ²¡æœ‰æ˜¾ç¤ºå‘ç”Ÿææ…Œçš„ç¡®åˆ‡è¡Œå·ã€‚</p>

<h2 id="expect">expect()</h2>

<p>ç±»ä¼¼<code>unwrap()</code>ä½†å¯ä»¥ä¸ºææ…Œè®¾ç½®è‡ªå®šä¹‰æ¶ˆæ¯ã€‚</p>

<pre><code class="language-rust">// 01. expect error message for None
fn main() {
    let n: Option&lt;i8&gt; = None;

    n.expect(&quot;empty value returned&quot;);
}

// --------------- Compile time error ---------------
thread 'main' panicked at 'empty value returned', libcore/option.rs:989:5


// 02. expect error message for Err
fn main() {
    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;some message&quot;);

    e.expect(&quot;expect error message&quot;);
}

// --------------- Compile time error ---------------
thread 'main' panicked at 'expect error message: &quot;some message&quot;', libcore/result.rs:945:5

</code></pre>

<h2 id="unwrap-err-and-expect-err-for-result-types">unwrap_err() and expect_err() for Result types</h2>

<p><code>unwrap()</code>å’Œ<code>expect()</code>ç›¸åçš„æƒ…å†µ;  <code>Ok</code>æ—¶ææ…Œè€Œä¸æ˜¯<code>Err</code>æ—¶ã€‚ä¸¤è€…éƒ½åœ¨<code>Ok</code>é”™è¯¯æ¶ˆæ¯ä¸­æ‰“å°å†…éƒ¨å€¼ã€‚</p>

<p>ğŸ’¡é€šå¸¸ç”¨äºæµ‹è¯•ã€‚</p>

<pre><code class="language-rust">// 01. unwrap_err error message for Ok
fn main() {
    let o: Result&lt;i8, &amp;str&gt; = Ok(8);

    o.unwrap_err();
}

// ---------- Compile time error ----------
thread 'main' panicked at 'called `Result::unwrap_err()` on an `Ok` value: 8', libcore/result.rs:945:5


// 02. expect_err error message for Ok
fn main() {
    let o: Result&lt;i8, &amp;str&gt; = Ok(8);

    o.expect_err(&quot;Should not get Ok value&quot;);
}

// ---------- Compile time error ----------
thread 'main' panicked at 'Should not get Ok value: 8', libcore/result.rs:945:5

</code></pre>

<h2 id="unwrap-or-unwrap-or-default-and-unwrap-or-else">unwrap_or(), unwrap_or_default() and unwrap_or_else()</h2>

<blockquote>
<p>ğŸ’¡è¿™äº›æœ‰ç‚¹ç±»ä¼¼äº<code>unwrap()</code>ï¼Œå¦‚æœ<code>Option</code>ç±»å‹æœ‰<code>Some</code>å€¼æˆ–<code>Result</code>ç±»å‹æœ‰<code>Ok</code>å€¼ï¼Œåˆ™å®ƒä»¬å†…éƒ¨çš„å€¼ä¼ é€’åˆ°ä¸‹ä¸€æ­¥ã€‚ä½†æ˜¯å½“æœ‰<code>None</code>æˆ–è€…  <code>Err</code>ï¼ŒåŠŸèƒ½æœ‰ç‚¹ä¸åŒã€‚</p>
</blockquote>

<ul>
<li><p><code>unwrap_or()</code>  ï¼šä½¿ç”¨<code>None</code>æˆ–<code>Err</code>ï¼Œæ‚¨ä¼ é€’ç»™çš„<code>unwrap_or()</code>å€¼å°†ä¼ é€’åˆ°ä¸‹ä¸€æ­¥ã€‚ä½†æ˜¯ï¼Œæ‚¨ä¼ é€’çš„å€¼çš„æ•°æ®ç±»å‹åº”ä¸ç›¸å…³<code>Some</code>æˆ–<code>Ok</code>çš„æ•°æ®ç±»å‹åŒ¹é…ã€‚</p>

<pre><code class="language-rust">fn main() {
let v1 = 8;
let v2 = 16;

let s_v1 = Some(8);
let n = None;

assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1
assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2

let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);
let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);

assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1
assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2
}

</code></pre></li>

<li><p><code>unwrap_or_default(</code>) ï¼šä½¿ç”¨<code>None</code>æˆ–<code>Err</code>ï¼Œç›¸å…³çš„æ•°æ®ç±»å‹çš„é»˜è®¤å€¼<code>Some</code>æˆ–è€…<code>Ok</code>ï¼Œä¼ é€’åˆ°ä¸‹ä¸€æ­¥ã€‚</p>

<pre><code class="language-rust">fn main() {
let v = 8;
let v_default = 0;

let s_v: Option&lt;i8&gt; = Some(8);
let n: Option&lt;i8&gt; = None;

assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v
assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v

let o_v: Result&lt;i8, &amp;str&gt; = Ok(8);
let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);

assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v
assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v
}

</code></pre></li>

<li><p><code>unwrap_or_else()</code>  ï¼šç±»ä¼¼äº<code>unwrap_or()</code>ã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼Œæ‚¨å¿…é¡»ä¼ é€’ä¸€ä¸ªé—­åŒ…ï¼Œå®ƒè¿”å›ä¸€ä¸ªå…·æœ‰<code>Some</code>æˆ–<code>Ok</code>ç›¸å…³æ•°æ®ç±»å‹çš„å€¼ï¼Œè€Œä¸æ˜¯ä¼ é€’ä¸€ä¸ªå€¼ã€‚</p>

<pre><code class="language-rust">fn main() {
let v1 = 8;
let v2 = 16;

let s_v1 = Some(8);
let n = None;
let fn_v2_for_option = || 16;

assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1
assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2

let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);
let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);
let fn_v2_for_result = |_| 16;

assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1
assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2
}

</code></pre></li>
</ul>

<h2 id="error-and-none-propagation">Error and None Propagation</h2>

<p>æˆ‘ä»¬åº”è¯¥ä½¿ç”¨ææ…Œ<code>panic!()</code>ï¼Œ<code>unwrap()</code>ï¼Œ<code>expect()</code>åªæœ‰å½“æˆ‘ä»¬æ²¡æœ‰ä¸€ä¸ªæ›´å¥½å¤„ç†åŠæ³•çš„æƒ…å†µã€‚æ­¤å¤–å¦‚æœä¸€ä¸ªå‡½æ•°åŒ…å«è¡¨è¾¾å¼æ—¢èƒ½äº§ç”Ÿ<code>None</code>ä¹Ÿèƒ½äº§ç”Ÿ<code>Err</code>ï¼Œ</p>

<p>â–¸æˆ‘ä»¬å¯ä»¥åœ¨åŒä¸€å‡½æ•°ä¸­å¤„ç†</p>

<p>â–¸æˆ‘ä»¬å¯ä»¥ç«‹å³è¿”å›<code>None</code>  å’Œ<code>Err</code>ç»™è°ƒç”¨è€…ã€‚å› æ­¤è°ƒç”¨è€…å¯ä»¥å†³å®šå¦‚ä½•å¤„ç†å®ƒä»¬ã€‚</p>

<p>ğŸ’¡ Noneç±»å‹æ— éœ€å§‹ç»ˆç”±å‡½æ•°çš„è°ƒç”¨è€…å¤„ç†ã€‚ä½†Rustså¤„ç†<code>Err</code>ç±»å‹çš„çº¦å®šæ˜¯ï¼Œç«‹å³å°†å®ƒä»¬è¿”å›ç»™è°ƒç”¨è€…ï¼Œä»¥ä¾¿ç»™è°ƒç”¨è€…æ›´å¤šçš„æ§åˆ¶æƒæ¥å†³å®šå¦‚ä½•å¤„ç†å®ƒä»¬ã€‚</p>

<h2 id="æ“ä½œç¬¦"><code>ï¼Ÿ</code>æ“ä½œç¬¦</h2>

<p>â–¸å¦‚æœ<code>Option</code>ç±»å‹å…·æœ‰<code>Some</code>å€¼æˆ–<code>Result</code>ç±»å‹å…·æœ‰<code>Ok</code>å€¼ï¼Œåˆ™å…¶ä¸­çš„å€¼å°†ä¼ é€’åˆ°ä¸‹ä¸€æ­¥ã€‚ â–¸å¦‚æœ<code>Option</code>ç±»å‹å…·æœ‰<code>None</code>å€¼æˆ–<code>Result</code>ç±»å‹å…·æœ‰<code>Err</code>å€¼ï¼Œåˆ™ç«‹å³å°†å®ƒä»¬è¿”å›ç»™å‡½æ•°çš„è°ƒç”¨è€…ã€‚</p>

<p>ç¤ºä¾‹<code>Option</code>ç±»å‹ï¼Œ</p>

<pre><code class="language-rust">fn main() {
    if complex_function().is_none() {
        println!(&quot;X not exists!&quot;);
    }
}

fn complex_function() -&gt; Option&lt;&amp;'static str&gt; {
    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(&quot;abc&quot;), set x to &quot;abc&quot;

    // some other code, ex
    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 19 `false` to `true` 

    Some(&quot;&quot;)
}

fn get_an_optional_value() -&gt; Option&lt;&amp;'static str&gt; {

    //if the optional value is not empty
    if false {
        return Some(&quot;abc&quot;);
    }

    //else
    None
}

</code></pre>

<p>ç¤ºä¾‹<code>Result</code>ç±»å‹ï¼Œ</p>

<pre><code class="language-rust">fn main() {
    // `main` function is the caller of `complex_function` function
    // So we handle errors of complex_function(), inside main()
    if complex_function().is_err() {
        println!(&quot;Can not calculate X!&quot;);
    }
}

fn complex_function() -&gt; Result&lt;u64, String&gt; {
    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255

    // some other code, ex
    println!(&quot;{}&quot;, x); // 255 ; if you change line 20 `true` to `false`

    Ok(0)
}

fn function_with_error() -&gt; Result&lt;u64, String&gt; {
    //if error happens
    if true {
        return Err(&quot;some message&quot;.to_string());
    }

    // else, return valid output
    Ok(255)
}

</code></pre>

<h2 id="ä»main-ä¼ æ’­é”™è¯¯">ä»mainï¼ˆï¼‰ä¼ æ’­é”™è¯¯</h2>

<p>åœ¨Rustç‰ˆæœ¬1.26ä¹‹å‰ï¼Œæˆ‘ä»¬æ— æ³•ä»main()å‡½æ•°ä¼ æ’­<code>Result</code>å’Œ<code>Option</code>ã€‚ä½†æ˜¯ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»main()å‡½æ•°ä¸­ä¼ æ’­<code>Result</code>ç±»å‹ï¼Œå¹¶æ‰“å°å‡º<code>Err</code>çš„<code>Debug</code>è¡¨ç¤ºå½¢å¼ã€‚</p>

<pre><code class="language-rust">use std::fs::File;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let _ = File::open(&quot;not-existing-file.txt&quot;)?;

    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()
}

// Because of the program can not find not-existing-file.txt , it produces,
//    Err(Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; })
// While propagating error, the program prints,
//    Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }

</code></pre>

<h2 id="combinators">Combinators</h2>

<p>è®©æˆ‘ä»¬çœ‹çœ‹ç»„åˆå™¨æ˜¯ä»€ä¹ˆï¼Œ</p>

<ul>
<li><p>â€œç»„åˆè€…â€çš„ä¸€ä¸ªå«ä¹‰æ˜¯æ›´åŠ éæ­£å¼çš„æ„ä¹‰ï¼ŒæŒ‡çš„æ˜¯ç»„åˆæ¨¡å¼ï¼Œä¸€ç§ä»¥ç»„åˆäº‹ç‰©çš„æ€æƒ³ä¸ºä¸­å¿ƒç»„ç»‡å›¾ä¹¦é¦†çš„é£æ ¼ã€‚é€šå¸¸å­˜åœ¨ä¸€äº›ç±»å‹Tï¼Œä¸€äº›ç”¨äºæ„é€ ç±»å‹Tçš„â€œåŸå§‹â€å€¼çš„å‡½æ•°ï¼Œä»¥åŠä¸€äº›å¯ä»¥ä»¥å„ç§æ–¹å¼ç»„åˆç±»å‹Tçš„å€¼ä»¥æ„å»ºç±»å‹Tçš„æ›´å¤æ‚å€¼çš„ â€œ ç»„åˆå™¨ â€ ã€‚å¦ä¸€ä¸ªå®šä¹‰æ˜¯â€œ æ²¡æœ‰è‡ªç”±å˜é‡çš„å‡½æ•° â€ï¼ˆ<a href="https://link.zhihu.com/?target=http%3A//wiki.haskell.org">http://wiki.haskell.org</a>ï¼‰</p></li>

<li><p>ç»„åˆå­æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå…¶ä»ç¨‹åºç‰‡æ®µæ„å»ºç¨‹åºç‰‡æ®µ ; ä»æŸç§æ„ä¹‰ä¸Šè¯´ï¼Œä½¿ç”¨ç»„åˆå™¨çš„ç¨‹åºå‘˜è‡ªåŠ¨æ„å»ºäº†å¤§éƒ¨åˆ†æ‰€éœ€çš„ç¨‹åºï¼Œè€Œä¸æ˜¯æ‰‹å·¥ç¼–å†™æ¯ä¸ªç»†èŠ‚ã€‚</p></li>
</ul>

<p>Rustç”Ÿæ€ç³»ç»Ÿä¸­â€œç»„åˆå­â€çš„ç¡®åˆ‡å®šä¹‰æœ‰ç‚¹ä¸æ¸…æ¥šã€‚</p>

<p>â–¸  <code>or()</code>ï¼Œ<code>and()</code>ï¼Œ<code>or_else()</code>ï¼Œ<code>and_then()</code>  - ç»„åˆç±»å‹ä¸ºTçš„ä¸¤ä¸ªå€¼å¹¶è¿”å›ç›¸åŒç±»å‹Tã€‚</p>

<p>â–¸  <code>filter()</code>å¯¹äºOptionç±»å‹ - ä½¿ç”¨é—­åŒ…ä½œä¸ºæ¡ä»¶å‡½æ•°æ¥è¿‡æ»¤ç±»å‹T. - è¿”å›ç›¸åŒçš„ç±»å‹T.</p>

<p>â–¸  <code>map()</code>ï¼Œ<code>map_err()</code>  - é€šè¿‡ä½¿ç”¨é—­åŒ…è½¬æ¢ç±»å‹Tã€‚ - å¯ä»¥æ›´æ”¹Tå†…éƒ¨å€¼çš„æ•°æ®ç±»å‹ã€‚ä¾‹å¦‚:<code>Some&lt;&amp;str&gt;</code>å¯è½¬åŒ–ä¸º<code>Some&lt;usize&gt;</code>æˆ–è€…<code>Err&lt;&amp;str&gt;</code>å¯è½¬åŒ–ä¸º<code>Err&lt;isize&gt;</code>ç­‰</p>

<p>â–¸  <code>map_or()</code>ï¼Œ<code>map_or_else()</code>  - é€šè¿‡åº”ç”¨é—­åŒ…è½¬æ¢ç±»å‹Tå¹¶è¿”å›ç±»å‹Tå†…çš„å€¼ã€‚ - å¯¹<code>None</code>  å’Œ<code>Err</code>ï¼Œåº”ç”¨é»˜è®¤å€¼æˆ–å…¶ä»–é—­åŒ…ã€‚</p>

<p>â–¸  <code>ok_or()</code>ï¼Œ<code>ok_or_else()</code>å¯¹äºOptionç±»å‹ - å°†Optionç±»å‹è½¬æ¢ä¸ºResultç±»å‹ã€‚</p>

<p>â–¸  <code>as_ref()</code>ï¼Œ<code>as_mut()</code>  - å°†ç±»å‹Tè½¬æ¢ä¸ºå¼•ç”¨æˆ–å¯å˜å¼•ç”¨ã€‚</p>

<h2 id="or-and-and">or() and and()</h2>

<p>ç»„åˆä¸¤ä¸ªè¡¨è¾¾å¼è¿”å›<code>Option/ Result</code></p>

<p>â–¸<code>or() ï¼šå¦‚æœä»»ä½•ä¸€ä¸ªå¾—åˆ°</code>Some<code>æˆ–</code>Ok`ï¼Œè¯¥å€¼ç«‹å³è¿”å›ã€‚</p>

<p>â–¸ and() ï¼šå¦‚æœä¸¤è€…éƒ½å¾—åˆ°<code>Some</code>æˆ–<code>Ok</code>ï¼Œåˆ™è¿”å›ç¬¬äºŒä¸ªè¡¨è¾¾å¼ä¸­çš„å€¼ã€‚å¦‚æœä»»ä½•ä¸€ä¸ªè·å¾—Noneæˆ–Errè¯¥å€¼ç«‹å³è¿”å›ã€‚</p>

<pre><code class="language-rust">fn main() {
  let s1 = Some(&quot;some1&quot;);
  let s2 = Some(&quot;some2&quot;);
  let n: Option&lt;&amp;str&gt; = None;

  let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);
  let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);
  let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);
  let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);

  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1
  assert_eq!(s1.or(n), s1);  // Some or None = Some
  assert_eq!(n.or(s1), s1);  // None or Some = Some
  assert_eq!(n.or(n), n);    // None1 or None2 = None2

  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1
  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok
  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok
  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2

  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2
  assert_eq!(s1.and(n), n);   // Some and None = None
  assert_eq!(n.and(s1), n);   // None and Some = None
  assert_eq!(n.and(n), n);    // None1 and None2 = None1

  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2
  assert_eq!(o1.and(e1), e1); // Ok and Err = Err
  assert_eq!(e1.and(o1), e1); // Err and Ok = Err
  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1
}

</code></pre>

<blockquote>
<p>ğŸ”nightlyæ”¯æŒOptionç±»å‹çš„<code>xor()</code>ï¼Œå®ƒè¿”å›<code>Some</code>å½“åªæœ‰ä¸€ä¸ªè¡¨è¾¾å¼è¿”å›<code>Some</code>ï¼Œè€Œä¸æ˜¯ä¸¤ä¸ªã€‚</p>
</blockquote>

<h2 id="or-else">or_else()</h2>

<p>ç±»ä¼¼äºor()ã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼Œç¬¬äºŒä¸ªè¡¨è¾¾å¼åº”è¯¥æ˜¯ä¸€ä¸ªè¿”å›ç›¸åŒç±»å‹T çš„é—­åŒ…ã€‚</p>

<pre><code class="language-rust">fn main() {
    // or_else with Option
    let s1 = Some(&quot;some1&quot;);
    let s2 = Some(&quot;some2&quot;);
    let fn_some = || Some(&quot;some2&quot;); // similar to: let fn_some = || -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };

    let n: Option&lt;&amp;str&gt; = None;
    let fn_none = || None;

    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1
    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some
    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some
    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2

    // or_else with Result
    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);
    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);
    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };

    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);
    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);
    let fn_err = |_| Err(&quot;error2&quot;);

    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1
    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok
    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok
    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2
}

</code></pre>

<h2 id="and-then">and_then()</h2>

<p>ç±»ä¼¼äºand()ã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼Œç¬¬äºŒä¸ªè¡¨è¾¾å¼åº”è¯¥æ˜¯ä¸€ä¸ªè¿”å›ç›¸åŒç±»å‹T çš„é—­åŒ…ã€‚</p>

<pre><code class="language-rust">fn main() {
    // and_then with Option
    let s1 = Some(&quot;some1&quot;);
    let s2 = Some(&quot;some2&quot;);
    let fn_some = |_| Some(&quot;some2&quot;); // similar to: let fn_some = |_| -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };

    let n: Option&lt;&amp;str&gt; = None;
    let fn_none = |_| None;

    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2
    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None
    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None
    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1

    // and_then with Result
    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);
    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);
    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };

    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);
    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);
    let fn_err = |_| Err(&quot;error2&quot;);

    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2
    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err
    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err
    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1
}

</code></pre>

<h2 id="filter">filter()</h2>

<blockquote>
<p>ğŸ’¡é€šå¸¸åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œfilterå‡½æ•°ä¸æ•°ç»„æˆ–è¿­ä»£å™¨ä¸€èµ·ä½¿ç”¨ï¼Œé€šè¿‡å‡½æ•°/é—­åŒ…è¿‡æ»¤è‡ªå·±çš„å…ƒç´ æ¥åˆ›å»ºæ–°çš„æ•°ç»„/è¿­ä»£å™¨ã€‚Rustè¿˜æä¾›äº†ä¸€ä¸ª<code>filter()</code>è¿­ä»£å™¨é€‚é…å™¨ï¼Œç”¨äºåœ¨è¿­ä»£å™¨çš„æ¯ä¸ªå…ƒç´ ä¸Šåº”ç”¨é—­åŒ…ï¼Œå°†å…¶è½¬æ¢ä¸ºå¦ä¸€ä¸ªè¿­ä»£å™¨ã€‚ç„¶è€Œï¼Œåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ­£åœ¨è°ˆè®º<code>filter()</code>å‡½æ•°ä¸<code>Option</code>ç±»å‹ã€‚</p>
</blockquote>

<p>ä»…å½“æˆ‘ä»¬ä¼ é€’ä¸€ä¸ª<code>Some</code>å€¼å¹¶ä¸”ç»™å®šçš„é—­åŒ…ä¸ºå®ƒè¿”å›<code>true</code>æ—¶,è¿”å›ç›¸åŒçš„<code>Some</code>ç±»å‹ã€‚å¦‚æœ<code>None</code>ä¼ é€’ç±»å‹æˆ–é—­åŒ…è¿”å›<code>false</code>,è¿”å›<code>None</code>ã€‚é—­åŒ…ä½¿ç”¨<code>Some</code>é‡Œé¢çš„å€¼ä½œä¸ºå‚æ•°ã€‚Rustä»ç„¶æ”¯æŒ<code>filter()</code>åªæ”¯æŒ<code>Option</code>çš„ç±»å‹ã€‚</p>

<pre><code class="language-rust">fn main() {
    let s1 = Some(3);
    let s2 = Some(6);
    let n = None;

    let fn_is_even = |x: &amp;i8| x % 2 == 0;

    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -&gt; 3 is not even -&gt; None
    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -&gt; 6 is even -&gt; Some(6)
    assert_eq!(n.filter(fn_is_even), n);   // None -&gt; no value -&gt; None
}

</code></pre>

<h2 id="map-and-map-err">map() and map_err()</h2>

<blockquote>
<p>ğŸ’¡é€šå¸¸åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œmap()å‡½æ•°ä¸æ•°ç»„æˆ–è¿­ä»£å™¨ä¸€èµ·ä½¿ç”¨ï¼Œä»¥åœ¨æ•°ç»„æˆ–è¿­ä»£å™¨çš„æ¯ä¸ªå…ƒç´ ä¸Šåº”ç”¨é—­åŒ…ã€‚Rustè¿˜æä¾›äº†ä¸€ä¸ª<code>map()</code>è¿­ä»£å™¨é€‚é…å™¨ï¼Œç”¨äºåœ¨è¿­ä»£å™¨çš„æ¯ä¸ªå…ƒç´ ä¸Šåº”ç”¨é—­åŒ…ï¼Œå°†å…¶è½¬æ¢ä¸ºå¦ä¸€ä¸ªè¿­ä»£å™¨ã€‚ä½†æ˜¯åœ¨è¿™é‡Œæˆ‘ä»¬è®¨è®ºçš„æ˜¯<code>map()</code>å‡½æ•°ä¸<code>Option</code>å’Œ<code>Result</code>ç±»å‹ã€‚</p>
</blockquote>

<ul>
<li><code>map()</code>  ï¼šé€šè¿‡åº”ç”¨é—­åŒ…æ¥è½¬æ¢ç±»å‹T. å¯ä»¥æ ¹æ®é—­åŒ…çš„è¿”å›ç±»å‹æ›´æ”¹<code>Some</code>æˆ–<code>Ok</code>å—æ•°æ®ç±»å‹ã€‚è½¬æ¢<code>Option&lt;T&gt;</code>ä¸º<code>Option&lt;U&gt;</code>  ï¼Œè½¬æ¢<code>Result&lt;T, E&gt;</code>ä¸º<code>Result&lt;U, E&gt;</code></li>
</ul>

<p>â­  <code>map()</code>ï¼Œä»…ä»…  <code>Some</code>å’Œ<code>Ok</code>å€¼æ”¹å˜ã€‚å¯¹<code>Err</code>å†…éƒ¨å€¼æ²¡æœ‰å½±å“ï¼ˆ<code>None</code>æ ¹æœ¬ä¸åŒ…å«ä»»ä½•å€¼ï¼‰ã€‚</p>

<pre><code class="language-rust">fn main() {
    let s1 = Some(&quot;abcde&quot;);
    let s2 = Some(5);

    let n1: Option&lt;&amp;str&gt; = None;
    let n2: Option&lt;usize&gt; = None;

    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let o2: Result&lt;usize, &amp;str&gt; = Ok(5);

    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;abcde&quot;);
    let e2: Result&lt;usize, &amp;str&gt; = Err(&quot;abcde&quot;);

    let fn_character_count = |s: &amp;str| s.chars().count();

    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2
    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2

    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2
    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2
}

</code></pre>

<ul>
<li><code>map_err()</code>å¯¹äº<code>Result</code>ç±»å‹ï¼šErrå—çš„æ•°æ®ç±»å‹å¯ä»¥æ ¹æ®é—­åŒ…çš„è¿”å›ç±»å‹è¿›è¡Œæ›´æ”¹ã€‚è½¬æ¢<code>Result&lt;T, E&gt;</code>ä¸º<code>Result&lt;T, F&gt;</code>ã€‚</li>
</ul>

<p>â­<code>map_err()</code>ï¼Œåªæœ‰<code>Err</code>å€¼ä¼šå‘ç”Ÿå˜åŒ–ã€‚å¯¹<code>Ok</code>å†…éƒ¨çš„å€¼æ²¡æœ‰å½±å“ã€‚</p>

<pre><code class="language-rust">fn main() {
    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let o2: Result&lt;&amp;str, isize&gt; = Ok(&quot;abcde&quot;);

    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;404&quot;);
    let e2: Result&lt;&amp;str, isize&gt; = Err(404);

    let fn_character_count = |s: &amp;str| -&gt; isize { s.parse().unwrap() }; // convert str to isize

    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2
    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2
}

</code></pre>

<h2 id="map-or-and-map-or-else">map_or() and map_or_else()</h2>

<p>è¿™äº›åŠŸèƒ½ä¹Ÿä¸<code>unwrap_or()</code>å’Œ<code>unwrap_or_else()</code>ç›¸ä¼¼ã€‚ä½†æ˜¯<code>map_or()</code>å’Œ<code>map_or_else()</code>åœ¨<code>Some</code>ï¼Œ<code>Ok</code>å€¼ä¸Šåº”ç”¨é—­åŒ…å’Œè¿”å›ç±»å‹Tå†…çš„å€¼ã€‚</p>

<ul>
<li><p><code>map_or()</code>  ï¼šä»…æ”¯æŒ<code>Option</code>ç±»å‹ï¼ˆä¸æ”¯æŒ<code>Result</code>ï¼‰ã€‚å°†é—­åŒ…åº”ç”¨äº<code>Some</code>å†…éƒ¨å€¼å¹¶æ ¹æ®é—­åŒ…è¿”å›è¾“å‡ºã€‚ä¸ºNoneç±»å‹è¿”å›ç»™å®šçš„é»˜è®¤å€¼ã€‚</p>

<pre><code class="language-rust">fn main() {
const V_DEFAULT: i8 = 1;

let s = Some(10);
let n: Option&lt;i8&gt; = None;
let fn_closure = |v: i8| v + 2;

assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);
assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);
}

</code></pre></li>

<li><p><code>map_or_else()</code>  ï¼šæ”¯æŒä¸¤ç§<code>Option</code>å’Œ<code>Result</code>ç±»å‹ï¼ˆResultä»…é™nightlyï¼‰ã€‚ç±»ä¼¼<code>map_or()</code>ä½†åº”è¯¥æä¾›å¦ä¸€ä¸ªé—­åŒ…è€Œä¸æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°çš„é»˜è®¤å€¼ã€‚</p></li>
</ul>

<p>â­  <code>None</code>ç±»å‹ä¸åŒ…å«ä»»ä½•å€¼ã€‚æ‰€ä»¥ä¸éœ€è¦å°†ä»»ä½•ä¸œè¥¿ä¼ é€’ç»™é—­åŒ…ä½œä¸ºè¾“å…¥Optionç±»å‹ã€‚ä½†æ˜¯<code>Err</code>ç±»å‹åœ¨å…¶ä¸­åŒ…å«ä¸€äº›å€¼ã€‚å› æ­¤ï¼Œé»˜è®¤é—­åŒ…åº”è¯¥èƒ½å¤Ÿå°†å…¶ä½œä¸ºè¾“å…¥è¯»å–ï¼ŒåŒæ—¶å°†å…¶ä¸<code>Result</code>ç±»å‹ä¸€èµ·ä½¿ç”¨ã€‚</p>

<pre><code class="language-rust">#![feature(result_map_or_else)] // enable unstable library feature 'result_map_or_else' on nightly
fn main() {
    let s = Some(10);
    let n: Option&lt;i8&gt; = None;

    let fn_closure = |v: i8| v + 2;
    let fn_default = || 1; // None doesn't contain any value. So no need to pass anything to closure as input.

    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);
    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);

    let o = Ok(10);
    let e = Err(5);
    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input

    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);
    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);
}

</code></pre>

<h2 id="ok-or-and-ok-or-else">ok_or() and ok_or_else()</h2>

<p>å¦‚å‰æ‰€è¿°<code>ok_or(</code>)ï¼Œ<code>ok_or_else()</code>å°†<code>Option</code>ç±»å‹è½¬æ¢ä¸º<code>Result</code>ç±»å‹ã€‚<code>Some</code>å¯¹<code>Ok</code>å’Œ<code>None</code>å¯¹<code>Err</code>  ã€‚</p>

<ul>
<li><p><code>ok_or()</code>  ï¼šé»˜è®¤<code>Err</code>æ¶ˆæ¯åº”ä½œä¸ºå‚æ•°ä¼ é€’.</p>

<pre><code class="language-rust">fn main() {
const ERR_DEFAULT: &amp;str = &quot;error message&quot;;

let s = Some(&quot;abcde&quot;);
let n: Option&lt;&amp;str&gt; = None;

let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
let e: Result&lt;&amp;str, &amp;str&gt; = Err(ERR_DEFAULT);

assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)
assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)
}

</code></pre></li>

<li><p><code>ok_or_else()</code>ï¼šç±»ä¼¼äº<code>ok_or()</code>ã€‚åº”è¯¥å°†é—­åŒ…ä½œä¸ºå‚æ•°ä¼ é€’ã€‚</p>

<pre><code class="language-rust">fn main() {
let s = Some(&quot;abcde&quot;);
let n: Option&lt;&amp;str&gt; = None;
let fn_err_message = || &quot;error message&quot;;

let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
let e: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error message&quot;);

assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -&gt; Ok(T)
assert_eq!(n.ok_or_else(fn_err_message), e); // None -&gt; Err(default)
}

</code></pre></li>
</ul>

<h2 id="as-ref-and-as-mut">as_ref() and as_mut()</h2>

<p>ğŸ”å¦‚å‰æ‰€è¿°ï¼Œè¿™äº›å‡½æ•°ç”¨äºå€Ÿç”¨ç±»å‹Tä½œä¸ºå¼•ç”¨æˆ–ä½œä¸ºå¯å˜å¼•ç”¨ã€‚</p>

<ul>
<li><code>as_ref()</code>  ï¼šè½¬æ¢<code>Option&lt;T&gt;</code>åˆ°<code>Option&lt;&amp;T&gt;</code>å’Œ<code>Result&lt;T, E&gt;</code>åˆ°<code>Result&lt;&amp;T, &amp;E&gt;</code></li>
<li><code>as_mut()</code>  ï¼šè½¬æ¢<code>Option&lt;T&gt;</code>åˆ°<code>Option&lt;&amp;mut T&gt;</code>å’Œ<code>Result&lt;T, E&gt;</code>åˆ°<code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>
</ul>

<h2 id="è‡ªå®šä¹‰é”™è¯¯ç±»å‹">è‡ªå®šä¹‰é”™è¯¯ç±»å‹</h2>

<p>Rustå…è®¸æˆ‘ä»¬åˆ›å»ºè‡ªå·±çš„Errç±»å‹ã€‚æˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œ è‡ªå®šä¹‰é”™è¯¯ç±»å‹â€ã€‚</p>

<h2 id="error-trait">Error trait</h2>

<p>å¦‚æ‚¨æ‰€çŸ¥ï¼Œtraitså®šä¹‰äº†ç±»å‹å¿…é¡»æä¾›çš„åŠŸèƒ½ã€‚ä½†æ˜¯æˆ‘ä»¬ä¸éœ€è¦æ€»æ˜¯ä¸ºå¸¸ç”¨åŠŸèƒ½å®šä¹‰æ–°çš„ç‰¹æ€§ï¼Œå› ä¸ºRust æ ‡å‡†åº“æä¾›äº†ä¸€äº›å¯ä»¥åœ¨æˆ‘ä»¬è‡ªå·±çš„ç±»å‹ä¸Šå®ç°çš„å¯é‡ç”¨ç‰¹æ€§ã€‚åˆ›å»ºè‡ªå®šä¹‰é”™è¯¯ç±»å‹æ—¶ï¼Œ<a href="https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/error/trait.Error.html">std::error::Error</a>  traitå¯å¸®åŠ©æˆ‘ä»¬å°†ä»»ä½•ç±»å‹è½¬æ¢ä¸º<code>Err</code>ç±»å‹ã€‚</p>

<pre><code class="language-rust">use std::fmt::{Debug, Display};

pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + 'static)&gt; { ... }
}

</code></pre>

<p>ä¸€ä¸ªç‰¹è´¨å¯ä»¥ä»å¦ä¸€ä¸ªç‰¹è´¨ç»§æ‰¿ã€‚<code>trait Error: Debug + Display</code>æ„å‘³ç€<code>Error</code>ç‰¹è´¨ç»§æ‰¿<code>fmt::Debug</code>å’Œ<code>fmt::Display</code>ç‰¹è´¨ã€‚</p>

<pre><code class="language-rust">// traits inside Rust standard library core fmt module/ std::fmt
pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;
}

pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;
}

</code></pre>

<p>â–¸ Display - æœ€ç»ˆç”¨æˆ·åº”å¦‚ä½•å°†æ­¤é”™è¯¯è§†ä¸ºé¢å‘æ¶ˆæ¯/é¢å‘ç”¨æˆ·çš„è¾“å‡ºã€‚ - é€šå¸¸é€šè¿‡<code>println!(&quot;{}&quot;)</code>æˆ–æ‰“å°<code>eprintln!(&quot;{}&quot;)</code></p>

<p>â–¸ Debug - å¦‚ä½•æ˜¾ç¤ºErrwhileè°ƒè¯•/é¢å‘ç¨‹åºå‘˜çš„è¾“å‡ºã€‚ - é€šå¸¸æ‰“å°<code>println!(&quot;{:?}&quot;)</code>æˆ–<code>eprintln!(&quot;{:?}&quot;)</code>  - - æ¼‚äº®æ‰“å°ï¼Œå¯ä»¥ä½¿ç”¨<code>println!(&quot;{:#?}&quot;)</code>æˆ–<code>eprintln!(&quot;{:#?}&quot;)</code>ã€‚</p>

<p>â–¸ source() - æ­¤é”™è¯¯çš„è¾ƒä½çº§åˆ«æ¥æºï¼ˆå¦‚æœæœ‰ï¼‰ã€‚ - å¯é€‰çš„ã€‚</p>

<p>é¦–å…ˆï¼Œè®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•<code>std::error::Error</code>åœ¨æœ€ç®€å•çš„è‡ªå®šä¹‰é”™è¯¯ç±»å‹ä¸Šå®ç°ç‰¹å¾ã€‚</p>

<pre><code class="language-rust">use std::fmt;

// Custom error type; can be any type which defined in the current crate
// ğŸ’¡ In here, we use a simple &quot;unit struct&quot; to simplify the example
struct AppError;

// Implement std::fmt::Display for AppError
impl fmt::Display for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;An Error Occurred, Please Try Again!&quot;) // user-facing output
    }
}

// Implement std::fmt::Debug for AppError
impl fmt::Debug for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{{ file: {}, line: {} }}&quot;, file!(), line!()) // programmer-facing output
    }
}

// A sample function to produce an AppError Err
fn produce_error() -&gt; Result&lt;(), AppError&gt; {
    Err(AppError)
}

fn main() {
    match produce_error() {
        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // An Error Occurred, Please Try Again!
        _ =&gt; println!(&quot;No error&quot;),
    }

    eprintln!(&quot;{:?}&quot;, produce_error()); // Err({ file: src/main.rs, line: 17 })
}

</code></pre>

<p>å¸Œæœ›ä½ ç†è§£è¦ç‚¹ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬çœ‹ä¸€äº›å¸¦æœ‰é”™è¯¯ä»£ç å’Œé”™è¯¯æ¶ˆæ¯çš„è‡ªå®šä¹‰é”™è¯¯ç±»å‹ã€‚</p>

<pre><code class="language-rust">use std::fmt;

struct AppError {
    code: usize,
    message: String,
}

// Different error messages according to AppError.code
impl fmt::Display for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let err_msg = match self.code {
            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,
            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,
        };

        write!(f, &quot;{}&quot;, err_msg)
    }
}

// A unique format for dubugging output
impl fmt::Debug for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(
            f,
            &quot;AppError {{ code: {}, message: {} }}&quot;,
            self.code, self.message
        )
    }
}

fn produce_error() -&gt; Result&lt;(), AppError&gt; {
    Err(AppError {
        code: 404,
        message: String::from(&quot;Page not found&quot;),
    })
}

fn main() {
    match produce_error() {
        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!
        _ =&gt; println!(&quot;No error&quot;),
    }

    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })

    eprintln!(&quot;{:#?}&quot;, produce_error());
    // Err(
    //     AppError { code: 404, message: Page not found }
    // )
}

</code></pre>

<p>â­ï¸Rustæ ‡å‡†åº“ä¸ä»…æä¾›äº†å¯é‡ç”¨çš„ç‰¹æ€§ï¼Œè€Œä¸”è¿˜æœ‰åŠ©äºé€šè¿‡<code>#[derive]</code>å±æ€§ç¥å¥‡åœ°ç”Ÿæˆå°‘æ•°ç‰¹å¾çš„å®ç°ã€‚Rustæ”¯æŒ<code>derive</code>  <code>std::fmt::Debug</code>ï¼Œä¸ºè°ƒè¯•æ¶ˆæ¯æä¾›é»˜è®¤æ ¼å¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨structå‰å£°æ˜ä½¿ç”¨<code>#[derive(Debug)]</code>è·³è¿‡å®ç°<code>std::fmt::Debug</code>  è‡ªå®šä¹‰é”™è¯¯ç±»å‹ã€‚</p>

<pre><code class="language-rust">use std::fmt;

#[derive(Debug)] // derive std::fmt::Debug on AppError
struct AppError {
    code: usize,
    message: String,
}

impl fmt::Display for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let err_msg = match self.code {
            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,
            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,
        };

        write!(f, &quot;{}&quot;, err_msg)
    }
}

fn produce_error() -&gt; Result&lt;(), AppError&gt; {
    Err(AppError {
        code: 404,
        message: String::from(&quot;Page not found&quot;),
    })
}

fn main() {
    match produce_error() {
        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!
        _ =&gt; println!(&quot;No error&quot;),
    }

    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })

    eprintln!(&quot;{:#?}&quot;, produce_error());
    // Err(
    //     AppError {
    //         code: 404,
    //         message: &quot;Page not found&quot;
    //     }
    // )
}

</code></pre>

<h2 id="from-trait">From trait</h2>

<p>åœ¨ç¼–å†™çœŸå®çš„ç¨‹åºæ—¶ï¼Œæˆ‘ä»¬å¤§å¤šæ•°æ—¶å€™å¿…é¡»åŒæ—¶å¤„ç†ä¸åŒçš„æ¨¡å—ï¼Œä¸åŒçš„stdå’Œç¬¬ä¸‰æ–¹çš„æ¿æ¡ç®±ã€‚ä½†æ˜¯æ¯ä¸ªåŒ…éƒ½ä½¿ç”¨è‡ªå·±çš„é”™è¯¯ç±»å‹ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨è‡ªå·±çš„é”™è¯¯ç±»å‹ï¼Œæˆ‘ä»¬åº”è¯¥å°†è¿™äº›é”™è¯¯è½¬æ¢ä¸ºé”™è¯¯ç±»å‹ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>std::convert::From</code>æ ‡å‡†åŒ–ç‰¹å¾è¿›è¡Œè¿™äº›è½¬æ¢ã€‚</p>

<pre><code class="language-rust">// traits inside Rust standard library core convert module/ std::convert
pub trait From&lt;T&gt;: Sized {
  fn from(_: T) -&gt; Self;
}

</code></pre>

<blockquote>
<p>ğŸ’¡å¦‚æ‚¨æ‰€çŸ¥ï¼Œ<code>String::from()</code>å‡½æ•°ç”¨äºåˆ›å»º<code>String</code>  from  <code>&amp;str</code>æ•°æ®ç±»å‹ã€‚å®é™…ä¸Šè¿™ä¹Ÿæ˜¯<code>std::convert::From</code>ç‰¹è´¨çš„å®ç°ã€‚</p>
</blockquote>

<p>è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•åœ¨è‡ªå®šä¹‰é”™è¯¯ç±»å‹ä¸Šå®ç°<code>std::convert::From</code>ç‰¹å¾ã€‚</p>

<pre><code class="language-rust">use std::fs::File;
use std::io;

#[derive(Debug)]
struct AppError {
    kind: String,    // type of the error
    message: String, // error message
}

// Implement std::convert::From for AppError; from io::Error
impl From&lt;io::Error&gt; for AppError {
    fn from(error: io::Error) -&gt; Self {
        AppError {
            kind: String::from(&quot;io&quot;),
            message: error.to_string(),
        }
    }
}

fn main() -&gt; Result&lt;(), AppError&gt; {
    let _file = File::open(&quot;nonexistent_file.txt&quot;)?; // This generates an io::Error. But because of return type is Result&lt;(), AppError&gt;, it converts to AppError

    Ok(())
}


// --------------- Run time error ---------------
Error: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }

</code></pre>

<p>åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ<code>File::open(â€œnonexistent.txtâ€)?</code>äº§ç”Ÿ<code>std::io::Error</code>ã€‚ä½†ç”±äºè¿”å›ç±»å‹æ˜¯<code>Result&lt;(), AppError&gt;</code>ï¼Œå®ƒè½¬æ¢ä¸º<code>AppError</code>ã€‚å› ä¸ºæˆ‘ä»¬æ­£åœ¨ä»<code>main()</code>å‡½æ•°ä¼ æ’­é”™è¯¯ï¼Œæ‰€ä»¥å®ƒä¼šæ‰“å°å‡º<code>Err</code>çš„Debugè¡¨ç¤ºå½¢å¼ã€‚</p>

<p>åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åªå¤„ç†ä¸€ç§stdé”™è¯¯ç±»å‹<code>std::io::Error</code>ã€‚è®©æˆ‘ä»¬çœ‹ä¸€äº›å¤„ç†å¤šç§stdé”™è¯¯ç±»å‹çš„ä¾‹å­ã€‚</p>

<pre><code class="language-rust">use std::fs::File;
use std::io::{self, Read};
use std::num;

#[derive(Debug)]
struct AppError {
    kind: String,
    message: String,
}

// Implement std::convert::From for AppError; from io::Error
impl From&lt;io::Error&gt; for AppError {
    fn from(error: io::Error) -&gt; Self {
        AppError {
            kind: String::from(&quot;io&quot;),
            message: error.to_string(),
        }
    }
}

// Implement std::convert::From for AppError; from num::ParseIntError
impl From&lt;num::ParseIntError&gt; for AppError {
    fn from(error: num::ParseIntError) -&gt; Self {
        AppError {
            kind: String::from(&quot;parse&quot;),
            message: error.to_string(),
        }
    }
}

fn main() -&gt; Result&lt;(), AppError&gt; {
    let mut file = File::open(&quot;hello_world.txt&quot;)?; // generates an io::Error, if can not open the file and converts to an AppError

    let mut content = String::new();
    file.read_to_string(&amp;mut content)?; // generates an io::Error, if can not read file content and converts to an AppError

    let _number: usize;
    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError

    Ok(())
}


// --------------- Few possible run time errors ---------------

// 01. If hello_world.txt is a nonexistent file
Error: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }

// 02. If user doesn't have relevant permission to access hello_world.txt
Error: AppError { kind: &quot;io&quot;, message: &quot;Permission denied (os error 13)&quot; }

// 03. If hello_world.txt contains non-numeric content. ex Hello, world!
Error: AppError { kind: &quot;parse&quot;, message: &quot;invalid digit found in string&quot; }

</code></pre>

<blockquote>
<p>ğŸ” æœç´¢æœ‰å…³å®ç°çš„å†…å®¹<a href="https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/io/enum.ErrorKind.html">std::io::ErrorKind</a>ï¼Œä»¥äº†è§£å¦‚ä½•è¿›ä¸€æ­¥ç»„ç»‡é”™è¯¯ç±»å‹ã€‚</p>
</blockquote>

<p>å‘å¸ƒäº 2018-12-14</p>

</div>


    </main>

    
  </body>
</html>
